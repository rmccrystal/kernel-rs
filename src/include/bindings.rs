/* automatically generated by rust-bindgen 0.56.0 */

pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub use self::_IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION;
pub use self::_IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY;
pub use self::_IRQ_PRIORITY as IRQ_PRIORITY;
pub use self::_LOCK_OPERATION as LOCK_OPERATION;
pub use self::_MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE;
pub use self::_POOL_TYPE as POOL_TYPE;
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self { Self { storage, align: [] } }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where Storage: AsRef<[u8]> + AsMut<[u8]>
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type wchar_t = crate::include::raw::c_ushort;
pub type ULONG_PTR = crate::include::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type LONG64 = crate::include::raw::c_longlong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut crate::include::raw::c_void;
pub type CHAR = crate::include::raw::c_char;
pub type SHORT = crate::include::raw::c_short;
pub type LONG = crate::include::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCH = *mut WCHAR;
pub type PCHAR = *mut CHAR;
pub type PCCH = *const CHAR;
pub type UCHAR = crate::include::raw::c_uchar;
pub type USHORT = crate::include::raw::c_ushort;
pub type ULONG = crate::include::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type HANDLE = *mut crate::include::raw::c_void;
pub type CCHAR = crate::include::raw::c_char;
pub type CSHORT = crate::include::raw::c_short;
pub type LCID = ULONG;
pub type NTSTATUS = LONG;
pub type LONGLONG = crate::include::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LARGE_INTEGER), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
    assert_eq!(
        ::core::mem::size_of::<_LUID>(),
        8usize,
        concat!("Size of: ", stringify!(_LUID))
    );
    assert_eq!(
        ::core::mem::align_of::<_LUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LUID>())).LowPart as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LUID), "::", stringify!(LowPart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LUID>())).HighPart as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_LUID), "::", stringify!(HighPart))
    );
}
pub type LUID = _LUID;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    assert_eq!(
        ::core::mem::size_of::<_UNICODE_STRING>(),
        16usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_UNICODE_STRING>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_UNICODE_STRING>())).MaximumLength as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_UNICODE_STRING>())).Buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type UNICODE_STRING = _UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type BOOLEAN = UCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LIST_ENTRY>())).Flink as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LIST_ENTRY), "::", stringify!(Flink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LIST_ENTRY>())).Blink as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_LIST_ENTRY), "::", stringify!(Blink))
    );
}
pub type LIST_ENTRY = _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    assert_eq!(
        ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SINGLE_LIST_ENTRY>())).Next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: ULONG,
    pub Blink: ULONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY32() {
    assert_eq!(
        ::core::mem::size_of::<LIST_ENTRY32>(),
        8usize,
        concat!("Size of: ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        ::core::mem::align_of::<LIST_ENTRY32>(),
        4usize,
        concat!("Alignment of ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LIST_ENTRY32>())).Flink as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(LIST_ENTRY32), "::", stringify!(Flink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LIST_ENTRY32>())).Blink as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(LIST_ENTRY32), "::", stringify!(Blink))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING32 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONG,
}
#[test]
fn bindgen_test_layout__STRING32() {
    assert_eq!(
        ::core::mem::size_of::<_STRING32>(),
        8usize,
        concat!("Size of: ", stringify!(_STRING32))
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING32>(),
        4usize,
        concat!("Alignment of ", stringify!(_STRING32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_STRING32>())).Length as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_STRING32), "::", stringify!(Length))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_STRING32>())).MaximumLength as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING32),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_STRING32>())).Buffer as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_STRING32), "::", stringify!(Buffer))
    );
}
pub type STRING32 = _STRING32;
pub type UNICODE_STRING32 = STRING32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: crate::include::raw::c_ulong,
    pub Data2: crate::include::raw::c_ushort,
    pub Data3: crate::include::raw::c_ushort,
    pub Data4: [crate::include::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::core::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::core::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GUID>())).Data1 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GUID>())).Data2 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GUID>())).Data3 as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GUID>())).Data4 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data4))
    );
}
pub type GUID = _GUID;
pub type KIRQL = UCHAR;
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    _unused: [u8; 0],
}
pub type PEPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD {
    _unused: [u8; 0],
}
pub type PETHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    _unused: [u8; 0],
}
pub type PIO_TIMER = *mut _IO_TIMER;
pub type PRKPROCESS = *mut _KPROCESS;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PVPB = *mut _VPB;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
    assert_eq!(
        ::core::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LUID_AND_ATTRIBUTES>())).Luid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Luid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LUID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
    assert_eq!(
        ::core::mem::size_of::<_PRIVILEGE_SET>(),
        20usize,
        concat!("Size of: ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        ::core::mem::align_of::<_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).Control as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PRIVILEGE_SET>())).Privilege as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Privilege)
        )
    );
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = crate::include::raw::c_int;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
    assert_eq!(
        ::core::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        12usize,
        concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        ::core::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ImpersonationLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ContextTrackingMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ContextTrackingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).EffectiveOnly as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(EffectiveOnly)
        )
    );
}
pub type SECURITY_INFORMATION = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STATUS_BLOCK__bindgen_ty_1>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STATUS_BLOCK__bindgen_ty_1>())).Pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STATUS_BLOCK>())).Information as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG)>;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileIdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 37;
pub const _FILE_INFORMATION_CLASS_FileIdFullDirectoryInformation: _FILE_INFORMATION_CLASS = 38;
pub const _FILE_INFORMATION_CLASS_FileValidDataLengthInformation: _FILE_INFORMATION_CLASS = 39;
pub const _FILE_INFORMATION_CLASS_FileShortNameInformation: _FILE_INFORMATION_CLASS = 40;
pub const _FILE_INFORMATION_CLASS_FileIoCompletionNotificationInformation: _FILE_INFORMATION_CLASS = 41;
pub const _FILE_INFORMATION_CLASS_FileIoStatusBlockRangeInformation: _FILE_INFORMATION_CLASS = 42;
pub const _FILE_INFORMATION_CLASS_FileIoPriorityHintInformation: _FILE_INFORMATION_CLASS = 43;
pub const _FILE_INFORMATION_CLASS_FileSfioReserveInformation: _FILE_INFORMATION_CLASS = 44;
pub const _FILE_INFORMATION_CLASS_FileSfioVolumeInformation: _FILE_INFORMATION_CLASS = 45;
pub const _FILE_INFORMATION_CLASS_FileHardLinkInformation: _FILE_INFORMATION_CLASS = 46;
pub const _FILE_INFORMATION_CLASS_FileProcessIdsUsingFileInformation: _FILE_INFORMATION_CLASS = 47;
pub const _FILE_INFORMATION_CLASS_FileNormalizedNameInformation: _FILE_INFORMATION_CLASS = 48;
pub const _FILE_INFORMATION_CLASS_FileNetworkPhysicalNameInformation: _FILE_INFORMATION_CLASS = 49;
pub const _FILE_INFORMATION_CLASS_FileIdGlobalTxDirectoryInformation: _FILE_INFORMATION_CLASS = 50;
pub const _FILE_INFORMATION_CLASS_FileIsRemoteDeviceInformation: _FILE_INFORMATION_CLASS = 51;
pub const _FILE_INFORMATION_CLASS_FileUnusedInformation: _FILE_INFORMATION_CLASS = 52;
pub const _FILE_INFORMATION_CLASS_FileNumaNodeInformation: _FILE_INFORMATION_CLASS = 53;
pub const _FILE_INFORMATION_CLASS_FileStandardLinkInformation: _FILE_INFORMATION_CLASS = 54;
pub const _FILE_INFORMATION_CLASS_FileRemoteProtocolInformation: _FILE_INFORMATION_CLASS = 55;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationBypassAccessCheck: _FILE_INFORMATION_CLASS = 56;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationBypassAccessCheck: _FILE_INFORMATION_CLASS = 57;
pub const _FILE_INFORMATION_CLASS_FileVolumeNameInformation: _FILE_INFORMATION_CLASS = 58;
pub const _FILE_INFORMATION_CLASS_FileIdInformation: _FILE_INFORMATION_CLASS = 59;
pub const _FILE_INFORMATION_CLASS_FileIdExtdDirectoryInformation: _FILE_INFORMATION_CLASS = 60;
pub const _FILE_INFORMATION_CLASS_FileReplaceCompletionInformation: _FILE_INFORMATION_CLASS = 61;
pub const _FILE_INFORMATION_CLASS_FileHardLinkFullIdInformation: _FILE_INFORMATION_CLASS = 62;
pub const _FILE_INFORMATION_CLASS_FileIdExtdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 63;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformationEx: _FILE_INFORMATION_CLASS = 64;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationEx: _FILE_INFORMATION_CLASS = 65;
pub const _FILE_INFORMATION_CLASS_FileRenameInformationExBypassAccessCheck: _FILE_INFORMATION_CLASS = 66;
pub const _FILE_INFORMATION_CLASS_FileDesiredStorageClassInformation: _FILE_INFORMATION_CLASS = 67;
pub const _FILE_INFORMATION_CLASS_FileStatInformation: _FILE_INFORMATION_CLASS = 68;
pub const _FILE_INFORMATION_CLASS_FileMemoryPartitionInformation: _FILE_INFORMATION_CLASS = 69;
pub const _FILE_INFORMATION_CLASS_FileStatLxInformation: _FILE_INFORMATION_CLASS = 70;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformation: _FILE_INFORMATION_CLASS = 71;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationEx: _FILE_INFORMATION_CLASS = 72;
pub const _FILE_INFORMATION_CLASS_FileLinkInformationExBypassAccessCheck: _FILE_INFORMATION_CLASS = 73;
pub const _FILE_INFORMATION_CLASS_FileStorageReserveIdInformation: _FILE_INFORMATION_CLASS = 74;
pub const _FILE_INFORMATION_CLASS_FileCaseSensitiveInformationForceAccessCheck: _FILE_INFORMATION_CLASS = 75;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 76;
pub type _FILE_INFORMATION_CLASS = crate::include::raw::c_int;

pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyInformation: _DIRECTORY_NOTIFY_INFORMATION_CLASS = 1;
pub const _DIRECTORY_NOTIFY_INFORMATION_CLASS_DirectoryNotifyExtendedInformation: _DIRECTORY_NOTIFY_INFORMATION_CLASS =
    2;
pub type _DIRECTORY_NOTIFY_INFORMATION_CLASS = crate::include::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    assert_eq!(
        ::core::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFORMATION>())).CreationTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFORMATION>())).LastAccessTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFORMATION>())).LastWriteTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFORMATION>())).ChangeTime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_BASIC_INFORMATION>())).FileAttributes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    assert_eq!(
        ::core::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFORMATION>())).AllocationSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFORMATION>())).EndOfFile as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFORMATION>())).NumberOfLinks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFORMATION>())).DeletePending as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_STANDARD_INFORMATION>())).Directory as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory)
        )
    );
}
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    assert_eq!(
        ::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).CreationTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).LastAccessTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).LastWriteTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).ChangeTime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).AllocationSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).EndOfFile as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_NETWORK_OPEN_INFORMATION>())).FileAttributes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsDriverPathInformation: _FSINFOCLASS = 9;
pub const _FSINFOCLASS_FileFsVolumeFlagsInformation: _FSINFOCLASS = 10;
pub const _FSINFOCLASS_FileFsSectorSizeInformation: _FSINFOCLASS = 11;
pub const _FSINFOCLASS_FileFsDataCopyInformation: _FSINFOCLASS = 12;
pub const _FSINFOCLASS_FileFsMetadataSizeInformation: _FSINFOCLASS = 13;
pub const _FSINFOCLASS_FileFsFullSizeInformationEx: _FSINFOCLASS = 14;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 15;
pub type _FSINFOCLASS = crate::include::raw::c_int;

pub const _INTERFACE_TYPE_InterfaceTypeUndefined: _INTERFACE_TYPE = -1;
pub const _INTERFACE_TYPE_Internal: _INTERFACE_TYPE = 0;
pub const _INTERFACE_TYPE_Isa: _INTERFACE_TYPE = 1;
pub const _INTERFACE_TYPE_Eisa: _INTERFACE_TYPE = 2;
pub const _INTERFACE_TYPE_MicroChannel: _INTERFACE_TYPE = 3;
pub const _INTERFACE_TYPE_TurboChannel: _INTERFACE_TYPE = 4;
pub const _INTERFACE_TYPE_PCIBus: _INTERFACE_TYPE = 5;
pub const _INTERFACE_TYPE_VMEBus: _INTERFACE_TYPE = 6;
pub const _INTERFACE_TYPE_NuBus: _INTERFACE_TYPE = 7;
pub const _INTERFACE_TYPE_PCMCIABus: _INTERFACE_TYPE = 8;
pub const _INTERFACE_TYPE_CBus: _INTERFACE_TYPE = 9;
pub const _INTERFACE_TYPE_MPIBus: _INTERFACE_TYPE = 10;
pub const _INTERFACE_TYPE_MPSABus: _INTERFACE_TYPE = 11;
pub const _INTERFACE_TYPE_ProcessorInternal: _INTERFACE_TYPE = 12;
pub const _INTERFACE_TYPE_InternalPowerBus: _INTERFACE_TYPE = 13;
pub const _INTERFACE_TYPE_PNPISABus: _INTERFACE_TYPE = 14;
pub const _INTERFACE_TYPE_PNPBus: _INTERFACE_TYPE = 15;
pub const _INTERFACE_TYPE_Vmcs: _INTERFACE_TYPE = 16;
pub const _INTERFACE_TYPE_ACPIBus: _INTERFACE_TYPE = 17;
pub const _INTERFACE_TYPE_MaximumInterfaceType: _INTERFACE_TYPE = 18;
pub type _INTERFACE_TYPE = crate::include::raw::c_int;
pub type PINTERFACE_REFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PINTERFACE_DEREFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = crate::include::raw::c_int;

pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = crate::include::raw::c_int;
pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified: _DEVICE_POWER_STATE = 0;
pub const _DEVICE_POWER_STATE_PowerDeviceD0: _DEVICE_POWER_STATE = 1;
pub const _DEVICE_POWER_STATE_PowerDeviceD1: _DEVICE_POWER_STATE = 2;
pub const _DEVICE_POWER_STATE_PowerDeviceD2: _DEVICE_POWER_STATE = 3;
pub const _DEVICE_POWER_STATE_PowerDeviceD3: _DEVICE_POWER_STATE = 4;
pub const _DEVICE_POWER_STATE_PowerDeviceMaximum: _DEVICE_POWER_STATE = 5;
pub type _DEVICE_POWER_STATE = crate::include::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__POWER_STATE() {
    assert_eq!(
        ::core::mem::size_of::<_POWER_STATE>(),
        4usize,
        concat!("Size of: ", stringify!(_POWER_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_POWER_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_POWER_STATE>())).SystemState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_STATE),
            "::",
            stringify!(SystemState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_POWER_STATE>())).DeviceState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_STATE),
            "::",
            stringify!(DeviceState)
        )
    );
}
pub type POWER_STATE = _POWER_STATE;
pub const _POWER_STATE_TYPE_SystemPowerState: _POWER_STATE_TYPE = 0;
pub const _POWER_STATE_TYPE_DevicePowerState: _POWER_STATE_TYPE = 1;
pub type _POWER_STATE_TYPE = crate::include::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub ContextAsUlong: ULONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) } }

    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }

    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }

    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }

    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }

    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }

    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }

    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }

    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DirectedDripsTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Reserved2(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) } }

    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG, TargetSystemState: ULONG, EffectiveSystemState: ULONG, CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG, PseudoTransition: ULONG, KernelSoftReboot: ULONG, DirectedDripsTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 = unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
            KernelSoftReboot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DirectedDripsTransition: u32 = unsafe { ::core::mem::transmute(DirectedDripsTransition) };
            DirectedDripsTransition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>())).ContextAsUlong as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ContextAsUlong)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_STATE_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATE_CONTEXT))
    );
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).Length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).Length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).Level as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).Vector as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).Affinity
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Affinity)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Translated: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >()))
            .MessageCount as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MessageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Vector as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Affinity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Affinity)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
            >()))
            .Level as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
            >()))
            .Vector as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Vector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
            >()))
            .Affinity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Affinity)
        )
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>())).Raw
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(Raw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()))
                .Translated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(Translated)
        )
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).Length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).Channel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).Port as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).Reserved1
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).Channel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).RequestLine
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(RequestLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).TransferWidth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(TransferWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).Reserved1
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).Reserved2
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).Reserved3
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>())).Data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).DataSize
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).Reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).Reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).Length40
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length40)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).Length48
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length48)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Length64
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length64)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).Class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).Type as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).Reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).Reserved2
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).IdLowPart
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(IdLowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14>())).IdHighPart
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(IdHighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Generic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Generic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Interrupt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Interrupt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).MessageInterrupt as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(MessageInterrupt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Dma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Dma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).DmaV3 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DmaV3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).DevicePrivate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DevicePrivate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).BusNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(BusNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).DeviceSpecificData as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DeviceSpecificData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory40 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory40)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory48 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Connection as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Connection)
        )
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>(),
        20usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>())).ShareDisposition as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(ShareDisposition)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>())).Flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>())).u as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(u)
        )
    );
}
pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_LIST() {
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_LIST>(),
        28usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_LIST))
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_PARTIAL_RESOURCE_LIST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_LIST>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_LIST>())).Revision as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_LIST>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_PARTIAL_RESOURCE_LIST>())).PartialDescriptors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(PartialDescriptors)
        )
    );
}
pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__CM_FULL_RESOURCE_DESCRIPTOR() {
    assert_eq!(
        ::core::mem::size_of::<_CM_FULL_RESOURCE_DESCRIPTOR>(),
        36usize,
        concat!("Size of: ", stringify!(_CM_FULL_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_FULL_RESOURCE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_FULL_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_FULL_RESOURCE_DESCRIPTOR>())).InterfaceType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(InterfaceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_FULL_RESOURCE_DESCRIPTOR>())).BusNumber as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(BusNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_FULL_RESOURCE_DESCRIPTOR>())).PartialResourceList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(PartialResourceList)
        )
    );
}
pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_RESOURCE_LIST() {
    assert_eq!(
        ::core::mem::size_of::<_CM_RESOURCE_LIST>(),
        40usize,
        concat!("Size of: ", stringify!(_CM_RESOURCE_LIST))
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_RESOURCE_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_RESOURCE_LIST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_RESOURCE_LIST>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_RESOURCE_LIST),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_CM_RESOURCE_LIST>())).List as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_RESOURCE_LIST),
            "::",
            stringify!(List)
        )
    );
}
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
pub const _IRQ_DEVICE_POLICY_IrqPolicyMachineDefault: _IRQ_DEVICE_POLICY = 0;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllCloseProcessors: _IRQ_DEVICE_POLICY = 1;
pub const _IRQ_DEVICE_POLICY_IrqPolicyOneCloseProcessor: _IRQ_DEVICE_POLICY = 2;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachine: _IRQ_DEVICE_POLICY = 3;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpecifiedProcessors: _IRQ_DEVICE_POLICY = 4;
pub const _IRQ_DEVICE_POLICY_IrqPolicySpreadMessagesAcrossAllProcessors: _IRQ_DEVICE_POLICY = 5;
pub const _IRQ_DEVICE_POLICY_IrqPolicyAllProcessorsInMachineWhenSteered: _IRQ_DEVICE_POLICY = 6;
pub type _IRQ_DEVICE_POLICY = crate::include::raw::c_int;

pub const _IRQ_PRIORITY_IrqPriorityUndefined: _IRQ_PRIORITY = 0;
pub const _IRQ_PRIORITY_IrqPriorityLow: _IRQ_PRIORITY = 1;
pub const _IRQ_PRIORITY_IrqPriorityNormal: _IRQ_PRIORITY = 2;
pub const _IRQ_PRIORITY_IrqPriorityHigh: _IRQ_PRIORITY = 3;
pub type _IRQ_PRIORITY = crate::include::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).Alignment as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).Alignment as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).MinimumVector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(MinimumVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).MaximumVector as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(MaximumVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).AffinityPolicy as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(AffinityPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).PriorityPolicy as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PriorityPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>())).TargetedProcessors
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TargetedProcessors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>())).MinimumChannel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(MinimumChannel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>())).MaximumChannel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(MaximumChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).RequestLine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(RequestLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).Reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).Channel as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>())).TransferWidth as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(TransferWidth)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).Alignment as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>())).Data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>())).MinBusNumber as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(MinBusNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>())).MaxBusNumber as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(MaxBusNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>())).Reserved as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Priority as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Reserved1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>())).Reserved2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).Length40 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Length40)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).Alignment40 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Alignment40)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).Length48 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).Alignment48 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Alignment48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).Length64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).Alignment64 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Alignment64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).MinimumAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(MinimumAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>())).MaximumAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(MaximumAddress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Type as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Reserved1 as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).Reserved2 as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).IdLowPart as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(IdLowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>())).IdHighPart as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(IdHighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Interrupt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Interrupt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Dma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).DmaV3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DmaV3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Generic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Generic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).DevicePrivate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DevicePrivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).BusNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(BusNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).ConfigData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(ConfigData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory40 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory40)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory48 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory48)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Memory64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>())).Connection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Connection)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).Option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Option)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).Type as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).ShareDisposition as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(ShareDisposition)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).Spare1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).Spare2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_DESCRIPTOR>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(u)
        )
    );
}
pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_LIST() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_LIST>(),
        40usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_LIST))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_LIST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_LIST>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_LIST>())).Revision as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_LIST>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_LIST>())).Descriptors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Descriptors)
        )
    );
}
pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_REQUIREMENTS_LIST() {
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_REQUIREMENTS_LIST>(),
        72usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_REQUIREMENTS_LIST))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_REQUIREMENTS_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_REQUIREMENTS_LIST))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).ListSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(ListSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).InterfaceType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(InterfaceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).BusNumber as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(BusNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).SlotNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(SlotNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).Reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).AlternativeLists as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(AlternativeLists)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_RESOURCE_REQUIREMENTS_LIST>())).List as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(List)
        )
    );
}
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
pub type KPROCESSOR_MODE = CCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub SpareByte0: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KAPC() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC>(),
        88usize,
        concat!("Size of: ", stringify!(_KAPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC>(),
        8usize,
        concat!("Alignment of ", stringify!(_KAPC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).SpareByte0 as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(SpareByte0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).SpareByte1 as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(SpareByte1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).SpareLong0 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(SpareLong0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).Thread as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).ApcListEntry as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcListEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).Reserved as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Reserved))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).NormalContext as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(NormalContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).SystemArgument1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).SystemArgument2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).ApcStateIndex as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcStateIndex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).ApcMode as *const _ as usize },
        81usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcMode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC>())).Inserted as *const _ as usize },
        82usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Inserted))
    );
}
pub type KAPC = _KAPC;
pub type KDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Dpc: *mut _KDPC, DeferredContext: PVOID, SystemArgument1: PVOID, SystemArgument2: PVOID),
>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC__bindgen_ty_1__bindgen_ty_1>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC__bindgen_ty_1__bindgen_ty_1>())).Importance as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Importance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC__bindgen_ty_1__bindgen_ty_1>())).Number as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Number)
        )
    );
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KDPC__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_KDPC__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDPC__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC__bindgen_ty_1>())).TargetInfoAsUlong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1),
            "::",
            stringify!(TargetInfoAsUlong)
        )
    );
}
#[test]
fn bindgen_test_layout__KDPC() {
    assert_eq!(
        ::core::mem::size_of::<_KDPC>(),
        64usize,
        concat!("Size of: ", stringify!(_KDPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDPC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).DpcListEntry as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_KDPC), "::", stringify!(DpcListEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).ProcessorHistory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(ProcessorHistory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).DeferredRoutine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).DeferredContext as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).SystemArgument1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).SystemArgument2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDPC>())).DpcData as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_KDPC), "::", stringify!(DpcData))
    );
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
#[test]
fn bindgen_test_layout__MDL() {
    assert_eq!(
        ::core::mem::size_of::<_MDL>(),
        48usize,
        concat!("Size of: ", stringify!(_MDL))
    );
    assert_eq!(
        ::core::mem::align_of::<_MDL>(),
        8usize,
        concat!("Alignment of ", stringify!(_MDL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).Next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Next))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).Size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).MdlFlags as *const _ as usize },
        10usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(MdlFlags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).Process as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Process))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).MappedSystemVa as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(MappedSystemVa))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).StartVa as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(StartVa))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).ByteCount as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(ByteCount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MDL>())).ByteOffset as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(ByteOffset))
    );
}
pub type PMDL = *mut _MDL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: LONG,
    pub LockNV: LONG,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>())).Lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>())).LockNV as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LockNV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>())).Type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>())).Signalling as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Signalling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>())).Size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>())).Reserved1 as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Wake(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }

    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR, Wake: UCHAR, EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Absolute: u8 = unsafe { ::core::mem::transmute(Absolute) };
            Absolute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u8 = unsafe { ::core::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let EncodedTolerableDelay: u8 = unsafe { ::core::mem::transmute(EncodedTolerableDelay) };
            EncodedTolerableDelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>())).TimerControlFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(TimerControlFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) } }

    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }

    #[inline]
    pub fn Inserted(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Expired(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(Index: UCHAR, Inserted: UCHAR, Expired: UCHAR) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Index: u8 = unsafe { ::core::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Inserted: u8 = unsafe { ::core::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Expired: u8 = unsafe { ::core::mem::transmute(Expired) };
            Expired as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>())).TimerMiscFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(TimerMiscFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>())).TimerType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TimerType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>())).Hand as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Hand)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2ComponentId: UCHAR,
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2Running(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }

    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR, Timer2Expiring: UCHAR, Timer2CancelPending: UCHAR, Timer2SetPending: UCHAR,
        Timer2Running: UCHAR, Timer2Disabled: UCHAR, Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timer2Inserted: u8 = unsafe { ::core::mem::transmute(Timer2Inserted) };
            Timer2Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timer2Expiring: u8 = unsafe { ::core::mem::transmute(Timer2Expiring) };
            Timer2Expiring as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Timer2CancelPending: u8 = unsafe { ::core::mem::transmute(Timer2CancelPending) };
            Timer2CancelPending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Timer2SetPending: u8 = unsafe { ::core::mem::transmute(Timer2SetPending) };
            Timer2SetPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Timer2Running: u8 = unsafe { ::core::mem::transmute(Timer2Running) };
            Timer2Running as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Timer2Disabled: u8 = unsafe { ::core::mem::transmute(Timer2Disabled) };
            Timer2Disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Timer2ReservedFlags: u8 = unsafe { ::core::mem::transmute(Timer2ReservedFlags) };
            Timer2ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>())).Timer2Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(Timer2Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>())).Timer2Type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>())).Timer2ComponentId as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2ComponentId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>())).Timer2RelativeId as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2RelativeId)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }

    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR, DisableIncrement: UCHAR, QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIncrement: u8 = unsafe { ::core::mem::transmute(DisableIncrement) };
            DisableIncrement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let QueueReservedControlFlags: u8 = unsafe { ::core::mem::transmute(QueueReservedControlFlags) };
            QueueReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>())).QueueControlFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(QueueControlFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>())).QueueType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>())).QueueSize as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>())).QueueReserved as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueReserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) } }

    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn AffinitySet(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) } }

    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Tagged(&self) -> UCHAR { unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn SchedulerAssist(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_SchedulerAssist(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR, CounterProfiling: UCHAR, GroupScheduling: UCHAR, AffinitySet: UCHAR, Tagged: UCHAR,
        EnergyProfiling: UCHAR, SchedulerAssist: UCHAR, ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CycleProfiling: u8 = unsafe { ::core::mem::transmute(CycleProfiling) };
            CycleProfiling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CounterProfiling: u8 = unsafe { ::core::mem::transmute(CounterProfiling) };
            CounterProfiling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupScheduling: u8 = unsafe { ::core::mem::transmute(GroupScheduling) };
            GroupScheduling as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AffinitySet: u8 = unsafe { ::core::mem::transmute(AffinitySet) };
            AffinitySet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Tagged: u8 = unsafe { ::core::mem::transmute(Tagged) };
            Tagged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EnergyProfiling: u8 = unsafe { ::core::mem::transmute(EnergyProfiling) };
            EnergyProfiling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SchedulerAssist: u8 = unsafe { ::core::mem::transmute(SchedulerAssist) };
            SchedulerAssist as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ThreadReservedControlFlags: u8 = unsafe { ::core::mem::transmute(ThreadReservedControlFlags) };
            ThreadReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1>())).ThreadControlFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(ThreadControlFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ActiveDR7(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) } }

    #[inline]
    pub fn set_ActiveDR7(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Instrumented(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Instrumented(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Minimal(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) } }

    #[inline]
    pub fn set_Minimal(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Reserved4(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) } }

    #[inline]
    pub fn set_Reserved4(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }

    #[inline]
    pub fn AltSyscall(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) } }

    #[inline]
    pub fn set_AltSyscall(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn UmsScheduled(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) } }

    #[inline]
    pub fn set_UmsScheduled(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn UmsPrimary(&self) -> BOOLEAN { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) } }

    #[inline]
    pub fn set_UmsPrimary(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        ActiveDR7: BOOLEAN, Instrumented: BOOLEAN, Minimal: BOOLEAN, Reserved4: BOOLEAN, AltSyscall: BOOLEAN,
        UmsScheduled: BOOLEAN, UmsPrimary: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveDR7: u8 = unsafe { ::core::mem::transmute(ActiveDR7) };
            ActiveDR7 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Instrumented: u8 = unsafe { ::core::mem::transmute(Instrumented) };
            Instrumented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Minimal: u8 = unsafe { ::core::mem::transmute(Minimal) };
            Minimal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Reserved4: u8 = unsafe { ::core::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AltSyscall: u8 = unsafe { ::core::mem::transmute(AltSyscall) };
            AltSyscall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UmsScheduled: u8 = unsafe { ::core::mem::transmute(UmsScheduled) };
            UmsScheduled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let UmsPrimary: u8 = unsafe { ::core::mem::transmute(UmsPrimary) };
            UmsPrimary as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2>())).DebugActive
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2),
            "::",
            stringify!(DebugActive)
        )
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>())).ThreadType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ThreadType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>())).ThreadReserved as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ThreadReserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>())).MutantType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>())).MutantSize as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>())).DpcActive as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(DpcActive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>())).MutantReserved as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantReserved)
        )
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DISPATCHER_HEADER>())).SignalState as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DISPATCHER_HEADER>())).WaitListHead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(WaitListHead)
        )
    );
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    assert_eq!(
        ::core::mem::size_of::<_KEVENT>(),
        24usize,
        concat!("Size of: ", stringify!(_KEVENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_KEVENT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KEVENT>())).Header as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KEVENT), "::", stringify!(Header))
    );
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub const _LOCK_OPERATION_IoReadAccess: _LOCK_OPERATION = 0;
pub const _LOCK_OPERATION_IoWriteAccess: _LOCK_OPERATION = 1;
pub const _LOCK_OPERATION_IoModifyAccess: _LOCK_OPERATION = 2;
pub type _LOCK_OPERATION = crate::include::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    pub Busy: BOOLEAN,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1))
    );
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONG64 { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) } }

    #[inline]
    pub fn set_Reserved(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }

    #[inline]
    pub fn Hint(&self) -> LONG64 { unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) } }

    #[inline]
    pub fn set_Hint(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(Reserved: LONG64, Hint: LONG64) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Hint: u64 = unsafe { ::core::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE__bindgen_ty_1>())).Busy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE__bindgen_ty_1),
            "::",
            stringify!(Busy)
        )
    );
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE>(),
        40usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE>())).DeviceListHead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(DeviceListHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE>())).Lock as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Lock))
    );
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>(),
        24usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE_ENTRY>())).DeviceListEntry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(DeviceListEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE_ENTRY>())).SortKey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(SortKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KDEVICE_QUEUE_ENTRY>())).Inserted as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(Inserted)
        )
    );
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub const _MEMORY_CACHING_TYPE_MmNonCached: _MEMORY_CACHING_TYPE = 0;
pub const _MEMORY_CACHING_TYPE_MmCached: _MEMORY_CACHING_TYPE = 1;
pub const _MEMORY_CACHING_TYPE_MmWriteCombined: _MEMORY_CACHING_TYPE = 2;
pub const _MEMORY_CACHING_TYPE_MmHardwareCoherentCached: _MEMORY_CACHING_TYPE = 3;
pub const _MEMORY_CACHING_TYPE_MmNonCachedUnordered: _MEMORY_CACHING_TYPE = 4;
pub const _MEMORY_CACHING_TYPE_MmUSWCCached: _MEMORY_CACHING_TYPE = 5;
pub const _MEMORY_CACHING_TYPE_MmMaximumCacheType: _MEMORY_CACHING_TYPE = 6;
pub const _MEMORY_CACHING_TYPE_MmNotMapped: _MEMORY_CACHING_TYPE = -1;
pub type _MEMORY_CACHING_TYPE = crate::include::raw::c_int;

pub const _POOL_TYPE_NonPagedPool: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolExecute: _POOL_TYPE = 0;
pub const _POOL_TYPE_PagedPool: _POOL_TYPE = 1;
pub const _POOL_TYPE_NonPagedPoolMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_DontUseThisType: _POOL_TYPE = 3;
pub const _POOL_TYPE_NonPagedPoolCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_PagedPoolCacheAligned: _POOL_TYPE = 5;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_MaxPoolType: _POOL_TYPE = 7;
pub const _POOL_TYPE_NonPagedPoolBase: _POOL_TYPE = 0;
pub const _POOL_TYPE_NonPagedPoolBaseMustSucceed: _POOL_TYPE = 2;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAligned: _POOL_TYPE = 4;
pub const _POOL_TYPE_NonPagedPoolBaseCacheAlignedMustS: _POOL_TYPE = 6;
pub const _POOL_TYPE_NonPagedPoolSession: _POOL_TYPE = 32;
pub const _POOL_TYPE_PagedPoolSession: _POOL_TYPE = 33;
pub const _POOL_TYPE_NonPagedPoolMustSucceedSession: _POOL_TYPE = 34;
pub const _POOL_TYPE_DontUseThisTypeSession: _POOL_TYPE = 35;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedSession: _POOL_TYPE = 36;
pub const _POOL_TYPE_PagedPoolCacheAlignedSession: _POOL_TYPE = 37;
pub const _POOL_TYPE_NonPagedPoolCacheAlignedMustSSession: _POOL_TYPE = 38;
pub const _POOL_TYPE_NonPagedPoolNx: _POOL_TYPE = 512;
pub const _POOL_TYPE_NonPagedPoolNxCacheAligned: _POOL_TYPE = 516;
pub const _POOL_TYPE_NonPagedPoolSessionNx: _POOL_TYPE = 544;
pub type _POOL_TYPE = crate::include::raw::c_int;
extern "C" {
    pub fn ExAllocatePoolWithTag(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
extern "C" {
    pub fn ExFreePoolWithTag(P: PVOID, Tag: ULONG);
}
pub type ERESOURCE_THREAD = ULONG_PTR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub TableSize: ULONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1))
    );
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn OwnerCount(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) } }

    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG, OwnerReferenced: ULONG, IoQoSPriorityBoosted: ULONG, OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoPriorityBoosted) };
            IoPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnerReferenced: u32 = unsafe { ::core::mem::transmute(OwnerReferenced) };
            OwnerReferenced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoQoSPriorityBoosted) };
            IoQoSPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let OwnerCount: u32 = unsafe { ::core::mem::transmute(OwnerCount) };
            OwnerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_OWNER_ENTRY__bindgen_ty_1>())).TableSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OWNER_ENTRY__bindgen_ty_1),
            "::",
            stringify!(TableSize)
        )
    );
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY() {
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_OWNER_ENTRY>())).OwnerThread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OWNER_ENTRY),
            "::",
            stringify!(OwnerThread)
        )
    );
}
pub type OWNER_ENTRY = _OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: PVOID,
    pub ExclusiveWaiters: PVOID,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>())).ReservedLowFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ReservedLowFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>())).WaiterPriority as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaiterPriority)
        )
    );
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE__bindgen_ty_1>())).Flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1),
            "::",
            stringify!(Flag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    pub Address: PVOID,
    pub CreatorBackTraceIndex: ULONG_PTR,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE__bindgen_ty_2>())).Address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_2),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE__bindgen_ty_2>())).CreatorBackTraceIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_2),
            "::",
            stringify!(CreatorBackTraceIndex)
        )
    );
}
#[test]
fn bindgen_test_layout__ERESOURCE() {
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE>(),
        104usize,
        concat!("Size of: ", stringify!(_ERESOURCE))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_ERESOURCE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).SystemResourcesList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(SystemResourcesList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).OwnerTable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(OwnerTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).ActiveCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ActiveCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).SharedWaiters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(SharedWaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).ExclusiveWaiters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ExclusiveWaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).OwnerEntry as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(OwnerEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).ActiveEntries as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ActiveEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).ContentionCount as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ContentionCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).NumberOfSharedWaiters as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(NumberOfSharedWaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).NumberOfExclusiveWaiters as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(NumberOfExclusiveWaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).Reserved2 as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_ERESOURCE), "::", stringify!(Reserved2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ERESOURCE>())).SpinLock as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_ERESOURCE), "::", stringify!(SpinLock))
    );
}
extern "C" {
    pub fn MmProbeAndLockPages(MemoryDescriptorList: PMDL, AccessMode: KPROCESSOR_MODE, Operation: LOCK_OPERATION);
}
extern "C" {
    pub fn MmUnlockPages(MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmProtectMdlSystemAddress(MemoryDescriptorList: PMDL, NewProtect: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn MmMapLockedPagesSpecifyCache(
        MemoryDescriptorList: PMDL, AccessMode: KPROCESSOR_MODE, CacheType: MEMORY_CACHING_TYPE,
        RequestedAddress: PVOID, BugCheckOnFailure: ULONG, Priority: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn MmUnmapLockedPages(BaseAddress: PVOID, MemoryDescriptorList: PMDL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
#[test]
fn bindgen_test_layout__SECURITY_SUBJECT_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<_SECURITY_SUBJECT_CONTEXT>(),
        32usize,
        concat!("Size of: ", stringify!(_SECURITY_SUBJECT_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_SECURITY_SUBJECT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_SUBJECT_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_SUBJECT_CONTEXT>())).ClientToken as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ClientToken)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_SUBJECT_CONTEXT>())).ImpersonationLevel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_SUBJECT_CONTEXT>())).PrimaryToken as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(PrimaryToken)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECURITY_SUBJECT_CONTEXT>())).ProcessAuditId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ProcessAuditId)
        )
    );
}
pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
#[test]
fn bindgen_test_layout__INITIAL_PRIVILEGE_SET() {
    assert_eq!(
        ::core::mem::size_of::<_INITIAL_PRIVILEGE_SET>(),
        44usize,
        concat!("Size of: ", stringify!(_INITIAL_PRIVILEGE_SET))
    );
    assert_eq!(
        ::core::mem::align_of::<_INITIAL_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_INITIAL_PRIVILEGE_SET))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INITIAL_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INITIAL_PRIVILEGE_SET>())).Control as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INITIAL_PRIVILEGE_SET>())).Privilege as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(Privilege)
        )
    );
}
pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout__ACCESS_STATE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_ACCESS_STATE__bindgen_ty_1>(),
        44usize,
        concat!("Size of: ", stringify!(_ACCESS_STATE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ACCESS_STATE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_STATE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE__bindgen_ty_1>())).InitialPrivilegeSet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE__bindgen_ty_1),
            "::",
            stringify!(InitialPrivilegeSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE__bindgen_ty_1>())).PrivilegeSet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE__bindgen_ty_1),
            "::",
            stringify!(PrivilegeSet)
        )
    );
}
#[test]
fn bindgen_test_layout__ACCESS_STATE() {
    assert_eq!(
        ::core::mem::size_of::<_ACCESS_STATE>(),
        160usize,
        concat!("Size of: ", stringify!(_ACCESS_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_ACCESS_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_ACCESS_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).OperationID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(OperationID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).SecurityEvaluated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SecurityEvaluated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).GenerateAudit as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(GenerateAudit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).GenerateOnClose as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(GenerateOnClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).PrivilegesAllocated as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(PrivilegesAllocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).Flags as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(_ACCESS_STATE), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).RemainingDesiredAccess as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(RemainingDesiredAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).PreviouslyGrantedAccess as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(PreviouslyGrantedAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).OriginalDesiredAccess as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(OriginalDesiredAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).SubjectSecurityContext as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SubjectSecurityContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).SecurityDescriptor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).AuxData as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(AuxData)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).Privileges as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(Privileges)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).AuditPrivileges as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(AuditPrivileges)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).ObjectName as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(ObjectName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ACCESS_STATE>())).ObjectTypeName as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(ObjectTypeName)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__NAMED_PIPE_CREATE_PARAMETERS() {
    assert_eq!(
        ::core::mem::size_of::<_NAMED_PIPE_CREATE_PARAMETERS>(),
        40usize,
        concat!("Size of: ", stringify!(_NAMED_PIPE_CREATE_PARAMETERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NAMED_PIPE_CREATE_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NAMED_PIPE_CREATE_PARAMETERS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).NamedPipeType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(NamedPipeType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).ReadMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(ReadMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).CompletionMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(CompletionMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).MaximumInstances as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(MaximumInstances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).InboundQuota as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(InboundQuota)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).OutboundQuota as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(OutboundQuota)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).DefaultTimeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(DefaultTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_NAMED_PIPE_CREATE_PARAMETERS>())).TimeoutSpecified as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(TimeoutSpecified)
        )
    );
}
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__MAILSLOT_CREATE_PARAMETERS() {
    assert_eq!(
        ::core::mem::size_of::<_MAILSLOT_CREATE_PARAMETERS>(),
        24usize,
        concat!("Size of: ", stringify!(_MAILSLOT_CREATE_PARAMETERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_MAILSLOT_CREATE_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_MAILSLOT_CREATE_PARAMETERS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MAILSLOT_CREATE_PARAMETERS>())).MailslotQuota as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(MailslotQuota)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MAILSLOT_CREATE_PARAMETERS>())).MaximumMessageSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(MaximumMessageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MAILSLOT_CREATE_PARAMETERS>())).ReadTimeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(ReadTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_MAILSLOT_CREATE_PARAMETERS>())).TimeoutSpecified as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(TimeoutSpecified)
        )
    );
}
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {
    _unused: [u8; 0],
}
pub type DRIVER_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT, RegistryPath: PUNICODE_STRING) -> NTSTATUS,
>;
///
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_STARTIO =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD = ::core::option::Option<unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT)>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT, PhysicalDeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        CheckForReadOperation: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_BASIC_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_STANDARD_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PEPROCESS,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PVOID,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IoControlCode: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE = ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE = ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE =
    ::core::option::Option<unsafe extern "C" fn(SourceDevice: *mut _DEVICE_OBJECT, TargetDevice: *mut _DEVICE_OBJECT)>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: *mut _FILE_NETWORK_OPEN_INFORMATION,
        IoStatus: *mut _IO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT, MdlChain: PMDL, DeviceObject: *mut _DEVICE_OBJECT) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        EndingOffset: PLARGE_INTEGER,
        ResourceToRelease: *mut *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ResourceToRelease: *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT, DeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT, DeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    _unused: [u8; 0],
}
pub type FAST_IO_READ_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT, MdlChain: PMDL, DeviceObject: *mut _DEVICE_OBJECT) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN = ::core::option::Option<
    unsafe extern "C" fn(
        Irp: *mut _IRP,
        NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
#[test]
fn bindgen_test_layout__FAST_IO_DISPATCH() {
    assert_eq!(
        ::core::mem::size_of::<_FAST_IO_DISPATCH>(),
        224usize,
        concat!("Size of: ", stringify!(_FAST_IO_DISPATCH))
    );
    assert_eq!(
        ::core::mem::align_of::<_FAST_IO_DISPATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(_FAST_IO_DISPATCH))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).SizeOfFastIoDispatch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(SizeOfFastIoDispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoCheckIfPossible as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoCheckIfPossible)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoRead as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoWrite as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoQueryBasicInfo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryBasicInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoQueryStandardInfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryStandardInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoLock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoUnlockSingle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockSingle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoUnlockAll as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockAll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoUnlockAllByKey as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockAllByKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoDeviceControl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoDeviceControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).AcquireFileForNtCreateSection as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireFileForNtCreateSection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).ReleaseFileForNtCreateSection as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseFileForNtCreateSection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoDetachDevice as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoDetachDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoQueryNetworkOpenInfo as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryNetworkOpenInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).AcquireForModWrite as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireForModWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).MdlRead as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).MdlReadComplete as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlReadComplete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).PrepareMdlWrite as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(PrepareMdlWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).MdlWriteComplete as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlWriteComplete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoReadCompressed as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoReadCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoWriteCompressed as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoWriteCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).MdlReadCompleteCompressed as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlReadCompleteCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).MdlWriteCompleteCompressed as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlWriteCompleteCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).FastIoQueryOpen as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).ReleaseForModWrite as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseForModWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).AcquireForCcFlush as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireForCcFlush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FAST_IO_DISPATCH>())).ReleaseForCcFlush as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseForCcFlush)
        )
    );
}
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
pub const _IO_ALLOCATION_ACTION_KeepObject: _IO_ALLOCATION_ACTION = 1;
pub const _IO_ALLOCATION_ACTION_DeallocateObject: _IO_ALLOCATION_ACTION = 2;
pub const _IO_ALLOCATION_ACTION_DeallocateObjectKeepRegisters: _IO_ALLOCATION_ACTION = 3;
pub type _IO_ALLOCATION_ACTION = crate::include::raw::c_int;
pub type DRIVER_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        MapRegisterBase: PVOID,
        Context: PVOID,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
#[test]
fn bindgen_test_layout__IO_SECURITY_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<_IO_SECURITY_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_SECURITY_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_SECURITY_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_SECURITY_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_SECURITY_CONTEXT>())).SecurityQos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(SecurityQos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_SECURITY_CONTEXT>())).AccessState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(AccessState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_SECURITY_CONTEXT>())).DesiredAccess as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(DesiredAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_SECURITY_CONTEXT>())).FullCreateOptions as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(FullCreateOptions)
        )
    );
}
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__VPB() {
    assert_eq!(
        ::core::mem::size_of::<_VPB>(),
        96usize,
        concat!("Size of: ", stringify!(_VPB))
    );
    assert_eq!(
        ::core::mem::align_of::<_VPB>(),
        8usize,
        concat!("Alignment of ", stringify!(_VPB))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).Flags as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).VolumeLabelLength as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_VPB),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).DeviceObject as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(DeviceObject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).RealDevice as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(RealDevice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).SerialNumber as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(SerialNumber))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).ReferenceCount as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(ReferenceCount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_VPB>())).VolumeLabel as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(VolumeLabel))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>())).DmaWaitEntry as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DmaWaitEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>())).NumberOfChannels as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NumberOfChannels)
        )
    );
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }

    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DmaContext(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }

    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Reserved(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) } }

    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }

    #[inline]
    pub fn NumberOfRemapPages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }

    #[inline]
    pub fn set_NumberOfRemapPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG, DmaContext: ULONG, ZeroMapRegisters: ULONG, Reserved: ULONG, NumberOfRemapPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncCallback: u32 = unsafe { ::core::mem::transmute(SyncCallback) };
            SyncCallback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaContext: u32 = unsafe { ::core::mem::transmute(DmaContext) };
            DmaContext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ZeroMapRegisters: u32 = unsafe { ::core::mem::transmute(ZeroMapRegisters) };
            ZeroMapRegisters as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let NumberOfRemapPages: u32 = unsafe { ::core::mem::transmute(NumberOfRemapPages) };
            NumberOfRemapPages as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>())).WaitQueueEntry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1),
            "::",
            stringify!(WaitQueueEntry)
        )
    );
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK() {
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK>(),
        72usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_WAIT_CONTEXT_BLOCK))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).DeviceRoutine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).DeviceContext as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).NumberOfMapRegisters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(NumberOfMapRegisters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).DeviceObject as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).CurrentIrp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_WAIT_CONTEXT_BLOCK>())).BufferChainingDpc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(BufferChainingDpc)
        )
    );
}
pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT__bindgen_ty_1>())).ListEntry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT__bindgen_ty_1),
            "::",
            stringify!(ListEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT__bindgen_ty_1>())).Wcb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT__bindgen_ty_1),
            "::",
            stringify!(Wcb)
        )
    );
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT>(),
        336usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT>(),
        16usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).ReferenceCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ReferenceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DriverObject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DriverObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).NextDevice as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(NextDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).AttachedDevice as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AttachedDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).CurrentIrp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Timer as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Timer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Flags as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Characteristics as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Vpb as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Vpb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DeviceExtension as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceExtension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DeviceType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).StackSize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StackSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Queue as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).AlignmentRequirement as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DeviceQueue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Dpc as *const _ as usize },
        200usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Dpc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).ActiveThreadCount as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ActiveThreadCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).SecurityDescriptor as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DeviceLock as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).SectorSize as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Spare1 as *const _ as usize },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).DeviceObjectExtension as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceObjectExtension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_OBJECT>())).Reserved as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub InterruptCount: LONG,
    pub VerifierContext: PVOID,
}
#[test]
fn bindgen_test_layout__DEVOBJ_EXTENSION() {
    assert_eq!(
        ::core::mem::size_of::<_DEVOBJ_EXTENSION>(),
        112usize,
        concat!("Size of: ", stringify!(_DEVOBJ_EXTENSION))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVOBJ_EXTENSION>(),
        8usize,
        concat!("Alignment of ", stringify!(_DEVOBJ_EXTENSION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).Size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).DeviceObject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).PowerFlags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(PowerFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).Dope as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Dope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).ExtensionFlags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(ExtensionFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).DeviceNode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DeviceNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).AttachedTo as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(AttachedTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).StartIoCount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).StartIoKey as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).StartIoFlags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).Vpb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Vpb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).DependencyNode as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DependencyNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).InterruptContext as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(InterruptContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).InterruptCount as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(InterruptCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVOBJ_EXTENSION>())).VerifierContext as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(VerifierContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__DRIVER_EXTENSION() {
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_EXTENSION>(),
        40usize,
        concat!("Size of: ", stringify!(_DRIVER_EXTENSION))
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_EXTENSION>(),
        8usize,
        concat!("Alignment of ", stringify!(_DRIVER_EXTENSION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_EXTENSION>())).DriverObject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(DriverObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_EXTENSION>())).AddDevice as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(AddDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_EXTENSION>())).Count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_EXTENSION>())).ServiceKeyName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(ServiceKeyName)
        )
    );
}
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_OBJECT>(),
        336usize,
        concat!("Size of: ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DeviceObject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).Flags as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverStart as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverSection as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverSection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverExtension as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverExtension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverName as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).HardwareDatabase as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(HardwareDatabase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).FastIoDispatch as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(FastIoDispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverInit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverStartIo as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStartIo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).DriverUnload as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverUnload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DRIVER_OBJECT>())).MajorFunction as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(MajorFunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
#[test]
fn bindgen_test_layout__SECTION_OBJECT_POINTERS() {
    assert_eq!(
        ::core::mem::size_of::<_SECTION_OBJECT_POINTERS>(),
        24usize,
        concat!("Size of: ", stringify!(_SECTION_OBJECT_POINTERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_SECTION_OBJECT_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECTION_OBJECT_POINTERS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECTION_OBJECT_POINTERS>())).DataSectionObject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(DataSectionObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECTION_OBJECT_POINTERS>())).SharedCacheMap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(SharedCacheMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SECTION_OBJECT_POINTERS>())).ImageSectionObject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(ImageSectionObject)
        )
    );
}
pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_COMPLETION_CONTEXT>())).Port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_COMPLETION_CONTEXT>())).Key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Key)
        )
    );
}
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECT>(),
        216usize,
        concat!("Size of: ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).DeviceObject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Vpb as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Vpb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).FsContext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).FsContext2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).SectionObjectPointer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SectionObjectPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).PrivateCacheMap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(PrivateCacheMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).FinalStatus as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FinalStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).RelatedFileObject as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(RelatedFileObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).LockOperation as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LockOperation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).DeletePending as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).ReadAccess as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(ReadAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).WriteAccess as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(WriteAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).DeleteAccess as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeleteAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).SharedRead as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).SharedWrite as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).SharedDelete as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Flags as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).FileName as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).CurrentByteOffset as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Waiters as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Waiters))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Busy as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Busy))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).LastLock as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LastLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Lock as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).Event as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).CompletionContext as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CompletionContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).IrpListLock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(IrpListLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).IrpList as *const _ as usize },
        192usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(IrpList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_OBJECT>())).FileObjectExtension as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FileObjectExtension)
        )
    );
}
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub UserIosb: PIO_STATUS_BLOCK,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_2,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub MasterIrp: *mut _IRP,
    pub IrpCount: LONG,
    pub SystemBuffer: PVOID,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_1>())).MasterIrp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(MasterIrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_1>())).IrpCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(IrpCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_1>())).SystemBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(SystemBuffer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub AsynchronousParameters: _IRP__bindgen_ty_2__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub UserApcContext: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: PVOID,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).UserApcRoutine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcRoutine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).IssuingProcess as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(IssuingProcess)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_2__bindgen_ty_1>())).UserApcContext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(UserApcContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_2>())).AsynchronousParameters as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(AsynchronousParameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_2>())).AllocationSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(AllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    pub Overlay: _IRP__bindgen_ty_3__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
    _bindgen_union_align: [u64; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).DriverContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DriverContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>())).DeviceQueueEntry as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DeviceQueueEntry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    pub PacketType: ULONG,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .CurrentStackLocation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(CurrentStackLocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).PacketType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PacketType)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>())).ListEntry as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1>())).Thread as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1>())).AuxiliaryBuffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(AuxiliaryBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IRP__bindgen_ty_3__bindgen_ty_1>())).OriginalFileObject as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(OriginalFileObject)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3>(),
        88usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_3>())).Overlay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_3>())).Apc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3),
            "::",
            stringify!(Apc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP__bindgen_ty_3>())).CompletionKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3),
            "::",
            stringify!(CompletionKey)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP() {
    assert_eq!(
        ::core::mem::size_of::<_IRP>(),
        208usize,
        concat!("Size of: ", stringify!(_IRP))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP>(),
        16usize,
        concat!("Alignment of ", stringify!(_IRP))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Type as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Size as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).MdlAddress as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(MdlAddress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Flags as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).AssociatedIrp as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(AssociatedIrp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).ThreadListEntry as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(ThreadListEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).IoStatus as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(IoStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).RequestorMode as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(RequestorMode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).PendingReturned as *const _ as usize },
        65usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(PendingReturned))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).StackCount as *const _ as usize },
        66usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(StackCount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).CurrentLocation as *const _ as usize },
        67usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CurrentLocation))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Cancel as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Cancel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).CancelIrql as *const _ as usize },
        69usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CancelIrql))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).ApcEnvironment as *const _ as usize },
        70usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(ApcEnvironment))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).AllocationFlags as *const _ as usize },
        71usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(AllocationFlags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).UserIosb as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(UserIosb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).UserEvent as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(UserEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Overlay as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Overlay))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).CancelRoutine as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CancelRoutine))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).UserBuffer as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(UserBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IRP>())).Tail as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Tail))
    );
}
pub type IRP = _IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Context: PVOID) -> NTSTATUS>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
pub const _DEVICE_RELATION_TYPE_BusRelations: _DEVICE_RELATION_TYPE = 0;
pub const _DEVICE_RELATION_TYPE_EjectionRelations: _DEVICE_RELATION_TYPE = 1;
pub const _DEVICE_RELATION_TYPE_PowerRelations: _DEVICE_RELATION_TYPE = 2;
pub const _DEVICE_RELATION_TYPE_RemovalRelations: _DEVICE_RELATION_TYPE = 3;
pub const _DEVICE_RELATION_TYPE_TargetDeviceRelation: _DEVICE_RELATION_TYPE = 4;
pub const _DEVICE_RELATION_TYPE_SingleBusRelations: _DEVICE_RELATION_TYPE = 5;
pub const _DEVICE_RELATION_TYPE_TransportRelations: _DEVICE_RELATION_TYPE = 6;
pub type _DEVICE_RELATION_TYPE = crate::include::raw::c_int;

pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeUndefined: _DEVICE_USAGE_NOTIFICATION_TYPE = 0;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePaging: _DEVICE_USAGE_NOTIFICATION_TYPE = 1;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeHibernation: _DEVICE_USAGE_NOTIFICATION_TYPE = 2;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeDumpFile: _DEVICE_USAGE_NOTIFICATION_TYPE = 3;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeBoot: _DEVICE_USAGE_NOTIFICATION_TYPE = 4;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypePostDisplay: _DEVICE_USAGE_NOTIFICATION_TYPE = 5;
pub const _DEVICE_USAGE_NOTIFICATION_TYPE_DeviceUsageTypeGuestAssigned: _DEVICE_USAGE_NOTIFICATION_TYPE = 6;
pub type _DEVICE_USAGE_NOTIFICATION_TYPE = crate::include::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
#[test]
fn bindgen_test_layout__INTERFACE() {
    assert_eq!(
        ::core::mem::size_of::<_INTERFACE>(),
        32usize,
        concat!("Size of: ", stringify!(_INTERFACE))
    );
    assert_eq!(
        ::core::mem::align_of::<_INTERFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(_INTERFACE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INTERFACE>())).Size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INTERFACE>())).Version as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Version))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INTERFACE>())).Context as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INTERFACE>())).InterfaceReference as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_INTERFACE),
            "::",
            stringify!(InterfaceReference)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_INTERFACE>())).InterfaceDereference as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_INTERFACE),
            "::",
            stringify!(InterfaceDereference)
        )
    );
}
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_CAPABILITIES() {
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_CAPABILITIES>(),
        64usize,
        concat!("Size of: ", stringify!(_DEVICE_CAPABILITIES))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(_DEVICE_CAPABILITIES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).Version as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).Address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).UINumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(UINumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).DeviceState as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(DeviceState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).SystemWake as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(SystemWake)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).DeviceWake as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(DeviceWake)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).D1Latency as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D1Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).D2Latency as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D2Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DEVICE_CAPABILITIES>())).D3Latency as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D3Latency)
        )
    );
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }

    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DeviceD2(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }

    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn LockSupported(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }

    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Removable(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) } }

    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DockDevice(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) } }

    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn UniqueID(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) } }

    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn SilentInstall(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) } }

    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) } }

    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WakeFromD0(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) } }

    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WakeFromD1(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) } }

    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WakeFromD2(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) } }

    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WakeFromD3(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) } }

    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn NonDynamic(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) } }

    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Reserved1(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) } }

    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn SecureDevice(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) } }

    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn ChildOfVgaEnabledBridge(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_ChildOfVgaEnabledBridge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn DecodeIoOnBoot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }

    #[inline]
    pub fn set_DecodeIoOnBoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn Reserved(&self) -> ULONG { unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) } }

    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG, DeviceD2: ULONG, LockSupported: ULONG, EjectSupported: ULONG, Removable: ULONG,
        DockDevice: ULONG, UniqueID: ULONG, SilentInstall: ULONG, RawDeviceOK: ULONG, SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG, WakeFromD1: ULONG, WakeFromD2: ULONG, WakeFromD3: ULONG, HardwareDisabled: ULONG,
        NonDynamic: ULONG, WarmEjectSupported: ULONG, NoDisplayInUI: ULONG, Reserved1: ULONG, WakeFromInterrupt: ULONG,
        SecureDevice: ULONG, ChildOfVgaEnabledBridge: ULONG, DecodeIoOnBoot: ULONG, Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::core::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::core::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::core::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::core::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::core::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::core::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::core::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::core::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::core::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::core::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::core::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::core::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::core::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::core::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::core::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::core::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::core::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WakeFromInterrupt: u32 = unsafe { ::core::mem::transmute(WakeFromInterrupt) };
            WakeFromInterrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SecureDevice: u32 = unsafe { ::core::mem::transmute(SecureDevice) };
            SecureDevice as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ChildOfVgaEnabledBridge: u32 = unsafe { ::core::mem::transmute(ChildOfVgaEnabledBridge) };
            ChildOfVgaEnabledBridge as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DecodeIoOnBoot: u32 = unsafe { ::core::mem::transmute(DecodeIoOnBoot) };
            DecodeIoOnBoot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_SEQUENCE() {
    assert_eq!(
        ::core::mem::size_of::<_POWER_SEQUENCE>(),
        12usize,
        concat!("Size of: ", stringify!(_POWER_SEQUENCE))
    );
    assert_eq!(
        ::core::mem::align_of::<_POWER_SEQUENCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SEQUENCE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_POWER_SEQUENCE>())).SequenceD1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_POWER_SEQUENCE>())).SequenceD2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_POWER_SEQUENCE>())).SequenceD3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD3)
        )
    );
}
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceID: BUS_QUERY_ID_TYPE = 0;
pub const BUS_QUERY_ID_TYPE_BusQueryHardwareIDs: BUS_QUERY_ID_TYPE = 1;
pub const BUS_QUERY_ID_TYPE_BusQueryCompatibleIDs: BUS_QUERY_ID_TYPE = 2;
pub const BUS_QUERY_ID_TYPE_BusQueryInstanceID: BUS_QUERY_ID_TYPE = 3;
pub const BUS_QUERY_ID_TYPE_BusQueryDeviceSerialNumber: BUS_QUERY_ID_TYPE = 4;
pub const BUS_QUERY_ID_TYPE_BusQueryContainerID: BUS_QUERY_ID_TYPE = 5;
pub type BUS_QUERY_ID_TYPE = crate::include::raw::c_int;
pub const DEVICE_TEXT_TYPE_DeviceTextDescription: DEVICE_TEXT_TYPE = 0;
pub const DEVICE_TEXT_TYPE_DeviceTextLocationInformation: DEVICE_TEXT_TYPE = 1;
pub type DEVICE_TEXT_TYPE = crate::include::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>())).SecurityContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>())).Options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>())).FileAttributes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>())).ShareAccess as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ShareAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>())).EaLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(EaLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>())).SecurityContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SecurityContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>())).ShareAccess as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ShareAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Parameters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Parameters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>())).SecurityContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SecurityContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>())).Options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>())).Reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>())).ShareAccess as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ShareAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>())).Parameters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Parameters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>())).Key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>())).Flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>())).ByteOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ByteOffset)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>())).Key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>())).Flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>())).ByteOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(ByteOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>())).FileName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>())).FileInformationClass as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileInformationClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>())).FileIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileIndex)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>())).CompletionFilter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(CompletionFilter)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>())).CompletionFilter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(CompletionFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>())).DirectoryNotifyInformationClass
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(DirectoryNotifyInformationClass)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>())).FileInformationClass as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(FileInformationClass)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1>()))
                .ReplaceIfExists as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1>()))
                .AdvanceOnly as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AdvanceOnly)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1>())).ClusterCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
            "::",
            stringify!(ClusterCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1>())).DeleteHandle
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
            "::",
            stringify!(DeleteHandle)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>())).FileInformationClass
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(FileInformationClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>())).FileObject as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(FileObject)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>())).EaList as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>())).EaListLength as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaListLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>())).EaIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>())).FsInformationClass as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(FsInformationClass)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>())).FsInformationClass as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(FsInformationClass)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>())).OutputBufferLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(OutputBufferLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>())).InputBufferLength as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(InputBufferLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>())).FsControlCode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(FsControlCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>())).Type3InputBuffer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(Type3InputBuffer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>())).Key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>())).ByteOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(ByteOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>())).OutputBufferLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(OutputBufferLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>())).InputBufferLength as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(InputBufferLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>())).IoControlCode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(IoControlCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>())).Type3InputBuffer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(Type3InputBuffer)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>())).SecurityInformation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(SecurityInformation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>())).Length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>())).SecurityInformation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(SecurityInformation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>())).SecurityDescriptor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>())).Vpb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(Vpb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>())).DeviceObject as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(DeviceObject)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>())).Vpb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(Vpb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>())).DeviceObject as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(DeviceObject)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>())).Srb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22),
            "::",
            stringify!(Srb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>())).StartSid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(StartSid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>())).SidList as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(SidList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>())).SidListLength as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(SidListLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>())).Type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25),
            "::",
            stringify!(Type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>())).InterfaceType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(InterfaceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>())).Size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>())).Version as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>())).Interface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>())).InterfaceSpecificData
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(InterfaceSpecificData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>())).Capabilities as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27),
            "::",
            stringify!(Capabilities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>())).IoResourceRequirementList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28),
            "::",
            stringify!(IoResourceRequirementList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>())).WhichSpace as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(WhichSpace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>())).Buffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>())).Offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>())).Length as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub Lock: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>(),
        1usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>())).Lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30),
            "::",
            stringify!(Lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>())).IdType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31),
            "::",
            stringify!(IdType)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>())).DeviceTextType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32),
            "::",
            stringify!(DeviceTextType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>())).LocaleId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32),
            "::",
            stringify!(LocaleId)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>())).InPath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(InPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>())).Type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(Type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>())).PowerState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34),
            "::",
            stringify!(PowerState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>())).PowerSequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35),
            "::",
            stringify!(PowerSequence)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub Type: POWER_STATE_TYPE,
    pub __bindgen_padding_1: u32,
    pub State: POWER_STATE,
    pub __bindgen_padding_2: u32,
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    pub SystemContext: ULONG,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1>())).SystemContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
            "::",
            stringify!(SystemContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1>()))
                .SystemPowerStateContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
            "::",
            stringify!(SystemPowerStateContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>())).Type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>())).State as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>())).ShutdownType as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(ShutdownType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>())).AllocatedResources as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37),
            "::",
            stringify!(AllocatedResources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>())).AllocatedResourcesTranslated
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37),
            "::",
            stringify!(AllocatedResourcesTranslated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>())).ProviderId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(ProviderId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>())).DataPath as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(DataPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>())).BufferSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(BufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>())).Buffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(Buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>())).Argument1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>())).Argument2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>())).Argument3 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>())).Argument4 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument4)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Create as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).CreatePipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(CreatePipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).CreateMailslot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(CreateMailslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryDirectory as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDirectory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).NotifyDirectory as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(NotifyDirectory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).NotifyDirectoryEx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(NotifyDirectoryEx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryFile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetFile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryEa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryEa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetEa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetEa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryVolume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetVolume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).FileSystemControl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(FileSystemControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).LockControl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(LockControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).DeviceIoControl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(DeviceIoControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QuerySecurity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QuerySecurity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetSecurity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetSecurity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).MountVolume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(MountVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).VerifyVolume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(VerifyVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Scsi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Scsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryQuota as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryQuota)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetQuota as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetQuota)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryDeviceRelations as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDeviceRelations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryInterface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryInterface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).DeviceCapabilities as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(DeviceCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).FilterResourceRequirements as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(FilterResourceRequirements)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).ReadWriteConfig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(ReadWriteConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).SetLock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).QueryDeviceText as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDeviceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).UsageNotification as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(UsageNotification)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).WaitWake as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(WaitWake)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).PowerSequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(PowerSequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Power as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).StartDevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(StartDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).WMI as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(WMI)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION__bindgen_ty_1>())).Others as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Others)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION() {
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION>(),
        72usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STACK_LOCATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).MajorFunction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(MajorFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).MinorFunction as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(MinorFunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).Flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).Control as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).Parameters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).DeviceObject as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).FileObject as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(FileObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).CompletionRoutine as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(CompletionRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_STACK_LOCATION>())).Context as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Context)
        )
    );
}
extern "C" {
    pub fn IoAllocateMdl(
        VirtualAddress: PVOID, Length: ULONG, SecondaryBuffer: BOOLEAN, ChargeQuota: BOOLEAN, Irp: PIRP,
    ) -> PMDL;
}
extern "C" {
    pub fn IoFreeMdl(Mdl: PMDL);
}
extern "C" {
    pub fn IoGetCurrentProcess() -> PEPROCESS;
}
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [UCHAR; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    assert_eq!(
        ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SID_IDENTIFIER_AUTHORITY>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: UCHAR,
    pub SubAuthorityCount: UCHAR,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    assert_eq!(
        ::core::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SID>())).Revision as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_SID), "::", stringify!(Revision))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SID>())).SubAuthorityCount as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SID>())).IdentifierAuthority as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_SID>())).SubAuthority as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_SID), "::", stringify!(SubAuthority))
    );
}
pub type SID = _SID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub Sid: SID,
}
#[test]
fn bindgen_test_layout__FILE_GET_QUOTA_INFORMATION() {
    assert_eq!(
        ::core::mem::size_of::<_FILE_GET_QUOTA_INFORMATION>(),
        20usize,
        concat!("Size of: ", stringify!(_FILE_GET_QUOTA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_GET_QUOTA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_GET_QUOTA_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_GET_QUOTA_INFORMATION>())).NextEntryOffset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_GET_QUOTA_INFORMATION>())).SidLength as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_FILE_GET_QUOTA_INFORMATION>())).Sid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: *mut _KPROCESS,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1,
    pub KernelApcPending: BOOLEAN,
    pub __bindgen_anon_2: _KAPC_STATE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_1 {
    pub InProgressFlags: UCHAR,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__KAPC_STATE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(_KAPC_STATE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE__bindgen_ty_1__bindgen_ty_1))
    );
}
impl _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_KernelApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn SpecialApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_SpecialApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        KernelApcInProgress: BOOLEAN, SpecialApcInProgress: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelApcInProgress: u8 = unsafe { ::core::mem::transmute(KernelApcInProgress) };
            KernelApcInProgress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SpecialApcInProgress: u8 = unsafe { ::core::mem::transmute(SpecialApcInProgress) };
            SpecialApcInProgress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__KAPC_STATE__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(_KAPC_STATE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC_STATE__bindgen_ty_1>())).InProgressFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE__bindgen_ty_1),
            "::",
            stringify!(InProgressFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_2 {
    pub UserApcPendingAll: BOOLEAN,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__KAPC_STATE__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(_KAPC_STATE__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE__bindgen_ty_2__bindgen_ty_1))
    );
}
impl _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SpecialUserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_SpecialUserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn UserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }

    #[inline]
    pub fn set_UserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }

    #[inline]
    pub fn new_bitfield_1(
        SpecialUserApcPending: BOOLEAN, UserApcPending: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SpecialUserApcPending: u8 = unsafe { ::core::mem::transmute(SpecialUserApcPending) };
            SpecialUserApcPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UserApcPending: u8 = unsafe { ::core::mem::transmute(UserApcPending) };
            UserApcPending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__KAPC_STATE__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(_KAPC_STATE__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC_STATE__bindgen_ty_2>())).UserApcPendingAll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE__bindgen_ty_2),
            "::",
            stringify!(UserApcPendingAll)
        )
    );
}
#[test]
fn bindgen_test_layout__KAPC_STATE() {
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE>(),
        48usize,
        concat!("Size of: ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC_STATE>())).ApcListHead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcListHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC_STATE>())).Process as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_KAPC_STATE), "::", stringify!(Process))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_KAPC_STATE>())).KernelApcPending as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcPending)
        )
    );
}
pub type PRKAPC_STATE = *mut _KAPC_STATE;
extern "C" {
    pub fn KeStackAttachProcess(PROCESS: PRKPROCESS, ApcState: PRKAPC_STATE);
}
extern "C" {
    pub fn KeUnstackDetachProcess(ApcState: PRKAPC_STATE);
}
pub type BYTE = crate::include::raw::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION {
    pub Section: HANDLE,
    pub MappedBase: PVOID,
    pub ImageBase: PVOID,
    pub ImageSize: ULONG,
    pub Flags: ULONG,
    pub LoadOrderIndex: USHORT,
    pub InitOrderIndex: USHORT,
    pub LoadCount: USHORT,
    pub OffsetToFileName: USHORT,
    pub FullPathName: [UCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__RTL_PROCESS_MODULE_INFORMATION() {
    assert_eq!(
        ::core::mem::size_of::<_RTL_PROCESS_MODULE_INFORMATION>(),
        296usize,
        concat!("Size of: ", stringify!(_RTL_PROCESS_MODULE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_PROCESS_MODULE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_PROCESS_MODULE_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).Section as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(Section)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).MappedBase as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(MappedBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).ImageBase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).ImageSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(ImageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).Flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).LoadOrderIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(LoadOrderIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).InitOrderIndex as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(InitOrderIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).LoadCount as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(LoadCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).OffsetToFileName as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(OffsetToFileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULE_INFORMATION>())).FullPathName as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULE_INFORMATION),
            "::",
            stringify!(FullPathName)
        )
    );
}
pub type RTL_PROCESS_MODULE_INFORMATION = _RTL_PROCESS_MODULE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_PROCESS_MODULES {
    pub NumberOfModules: ULONG,
    pub Modules: [RTL_PROCESS_MODULE_INFORMATION; 1usize],
}
#[test]
fn bindgen_test_layout__RTL_PROCESS_MODULES() {
    assert_eq!(
        ::core::mem::size_of::<_RTL_PROCESS_MODULES>(),
        304usize,
        concat!("Size of: ", stringify!(_RTL_PROCESS_MODULES))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_PROCESS_MODULES>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_PROCESS_MODULES))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULES>())).NumberOfModules as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULES),
            "::",
            stringify!(NumberOfModules)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_PROCESS_MODULES>())).Modules as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_PROCESS_MODULES),
            "::",
            stringify!(Modules)
        )
    );
}
pub type PRTL_PROCESS_MODULES = *mut _RTL_PROCESS_MODULES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA32 {
    pub Length: ULONG,
    pub Initialized: UCHAR,
    pub SsHandle: ULONG,
    pub InLoadOrderModuleList: LIST_ENTRY32,
    pub InMemoryOrderModuleList: LIST_ENTRY32,
    pub InInitializationOrderModuleList: LIST_ENTRY32,
}
#[test]
fn bindgen_test_layout__PEB_LDR_DATA32() {
    assert_eq!(
        ::core::mem::size_of::<_PEB_LDR_DATA32>(),
        36usize,
        concat!("Size of: ", stringify!(_PEB_LDR_DATA32))
    );
    assert_eq!(
        ::core::mem::align_of::<_PEB_LDR_DATA32>(),
        4usize,
        concat!("Alignment of ", stringify!(_PEB_LDR_DATA32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).Initialized as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(Initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).SsHandle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(SsHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).InLoadOrderModuleList as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(InLoadOrderModuleList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).InMemoryOrderModuleList as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(InMemoryOrderModuleList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA32>())).InInitializationOrderModuleList as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA32),
            "::",
            stringify!(InInitializationOrderModuleList)
        )
    );
}
pub type PPEB_LDR_DATA32 = *mut _PEB_LDR_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32 {
    pub InLoadOrderLinks: LIST_ENTRY32,
    pub InMemoryOrderLinks: LIST_ENTRY32,
    pub InInitializationOrderLinks: LIST_ENTRY32,
    pub DllBase: ULONG,
    pub EntryPoint: ULONG,
    pub SizeOfImage: ULONG,
    pub FullDllName: UNICODE_STRING32,
    pub BaseDllName: UNICODE_STRING32,
    pub Flags: ULONG,
    pub LoadCount: USHORT,
    pub TlsIndex: USHORT,
    pub HashLinks: LIST_ENTRY32,
    pub TimeDateStamp: ULONG,
}
#[test]
fn bindgen_test_layout__LDR_DATA_TABLE_ENTRY32() {
    assert_eq!(
        ::core::mem::size_of::<_LDR_DATA_TABLE_ENTRY32>(),
        72usize,
        concat!("Size of: ", stringify!(_LDR_DATA_TABLE_ENTRY32))
    );
    assert_eq!(
        ::core::mem::align_of::<_LDR_DATA_TABLE_ENTRY32>(),
        4usize,
        concat!("Alignment of ", stringify!(_LDR_DATA_TABLE_ENTRY32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).InLoadOrderLinks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(InLoadOrderLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).InMemoryOrderLinks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(InMemoryOrderLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).InInitializationOrderLinks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(InInitializationOrderLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).DllBase as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(DllBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).EntryPoint as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(EntryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).SizeOfImage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).FullDllName as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(FullDllName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).BaseDllName as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(BaseDllName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).Flags as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).LoadCount as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(LoadCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).TlsIndex as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(TlsIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).HashLinks as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(HashLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY32>())).TimeDateStamp as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY32),
            "::",
            stringify!(TimeDateStamp)
        )
    );
}
pub type LDR_DATA_TABLE_ENTRY32 = _LDR_DATA_TABLE_ENTRY32;
pub type PLDR_DATA_TABLE_ENTRY32 = *mut _LDR_DATA_TABLE_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB32 {
    pub InheritedAddressSpace: UCHAR,
    pub ReadImageFileExecOptions: UCHAR,
    pub BeingDebugged: UCHAR,
    pub BitField: UCHAR,
    pub Mutant: ULONG,
    pub ImageBaseAddress: ULONG,
    pub Ldr: ULONG,
    pub ProcessParameters: ULONG,
    pub SubSystemData: ULONG,
    pub ProcessHeap: ULONG,
    pub FastPebLock: ULONG,
    pub AtlThunkSListPtr: ULONG,
    pub IFEOKey: ULONG,
    pub CrossProcessFlags: ULONG,
    pub UserSharedInfoPtr: ULONG,
    pub SystemReserved: ULONG,
    pub AtlThunkSListPtr32: ULONG,
    pub ApiSetMap: ULONG,
}
#[test]
fn bindgen_test_layout__PEB32() {
    assert_eq!(
        ::core::mem::size_of::<_PEB32>(),
        60usize,
        concat!("Size of: ", stringify!(_PEB32))
    );
    assert_eq!(
        ::core::mem::align_of::<_PEB32>(),
        4usize,
        concat!("Alignment of ", stringify!(_PEB32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).InheritedAddressSpace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(InheritedAddressSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).ReadImageFileExecOptions as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(ReadImageFileExecOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).BeingDebugged as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(BeingDebugged))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).BitField as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(BitField))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).Mutant as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(Mutant))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).ImageBaseAddress as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(ImageBaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).Ldr as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(Ldr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).ProcessParameters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(ProcessParameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).SubSystemData as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(SubSystemData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).ProcessHeap as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(ProcessHeap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).FastPebLock as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(FastPebLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).AtlThunkSListPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(AtlThunkSListPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).IFEOKey as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(IFEOKey))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).CrossProcessFlags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(CrossProcessFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).UserSharedInfoPtr as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(UserSharedInfoPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).SystemReserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(SystemReserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).AtlThunkSListPtr32 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(AtlThunkSListPtr32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB32>())).ApiSetMap as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_PEB32), "::", stringify!(ApiSetMap))
    );
}
pub type PPEB32 = *mut _PEB32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA {
    pub Length: ULONG,
    pub Initialized: BOOLEAN,
    pub SsHandle: PVOID,
    pub ModuleListLoadOrder: LIST_ENTRY,
    pub ModuleListMemoryOrder: LIST_ENTRY,
    pub ModuleListInitOrder: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__PEB_LDR_DATA() {
    assert_eq!(
        ::core::mem::size_of::<_PEB_LDR_DATA>(),
        64usize,
        concat!("Size of: ", stringify!(_PEB_LDR_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_PEB_LDR_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_PEB_LDR_DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).Length as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_PEB_LDR_DATA), "::", stringify!(Length))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).Initialized as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(Initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).SsHandle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(SsHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).ModuleListLoadOrder as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(ModuleListLoadOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).ModuleListMemoryOrder as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(ModuleListMemoryOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB_LDR_DATA>())).ModuleListInitOrder as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(ModuleListInitOrder)
        )
    );
}
pub type PPEB_LDR_DATA = *mut _PEB_LDR_DATA;
pub type PPS_POST_PROCESS_INIT_ROUTINE = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
    pub Reserved1: [BYTE; 16usize],
    pub Reserved2: [PVOID; 10usize],
    pub ImagePathName: UNICODE_STRING,
    pub CommandLine: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__RTL_USER_PROCESS_PARAMETERS() {
    assert_eq!(
        ::core::mem::size_of::<_RTL_USER_PROCESS_PARAMETERS>(),
        128usize,
        concat!("Size of: ", stringify!(_RTL_USER_PROCESS_PARAMETERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_USER_PROCESS_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_USER_PROCESS_PARAMETERS))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_USER_PROCESS_PARAMETERS>())).Reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_USER_PROCESS_PARAMETERS>())).Reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_USER_PROCESS_PARAMETERS>())).ImagePathName as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(ImagePathName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_RTL_USER_PROCESS_PARAMETERS>())).CommandLine as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(CommandLine)
        )
    );
}
pub type PRTL_USER_PROCESS_PARAMETERS = *mut _RTL_USER_PROCESS_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB {
    pub Reserved1: [BYTE; 2usize],
    pub BeingDebugged: BYTE,
    pub Reserved2: [BYTE; 1usize],
    pub Reserved3: [PVOID; 2usize],
    pub Ldr: PPEB_LDR_DATA,
    pub ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
    pub Reserved4: [PVOID; 3usize],
    pub AtlThunkSListPtr: PVOID,
    pub Reserved5: PVOID,
    pub Reserved6: ULONG,
    pub Reserved7: PVOID,
    pub Reserved8: ULONG,
    pub AtlThunkSListPtr32: ULONG,
    pub Reserved9: [PVOID; 45usize],
    pub Reserved10: [BYTE; 96usize],
    pub PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    pub Reserved11: [BYTE; 128usize],
    pub Reserved12: [PVOID; 1usize],
    pub SessionId: ULONG,
}
#[test]
fn bindgen_test_layout__PEB() {
    assert_eq!(
        ::core::mem::size_of::<_PEB>(),
        712usize,
        concat!("Size of: ", stringify!(_PEB))
    );
    assert_eq!(
        ::core::mem::align_of::<_PEB>(),
        8usize,
        concat!("Alignment of ", stringify!(_PEB))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved1 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).BeingDebugged as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(BeingDebugged))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved2 as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved3 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Ldr as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Ldr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).ProcessParameters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(ProcessParameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved4 as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).AtlThunkSListPtr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(AtlThunkSListPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved5 as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved6 as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved7 as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved8 as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved8))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).AtlThunkSListPtr32 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(AtlThunkSListPtr32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved9 as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved9))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved10 as *const _ as usize },
        464usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved10))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).PostProcessInitRoutine as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(PostProcessInitRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved11 as *const _ as usize },
        568usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved11))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).Reserved12 as *const _ as usize },
        696usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Reserved12))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PEB>())).SessionId as *const _ as usize },
        704usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(SessionId))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY {
    pub InLoadOrderModuleList: LIST_ENTRY,
    pub InMemoryOrderModuleList: LIST_ENTRY,
    pub InInitializationOrderModuleList: LIST_ENTRY,
    pub DllBase: PVOID,
    pub EntryPoint: PVOID,
    pub SizeOfImage: ULONG,
    pub FullDllName: UNICODE_STRING,
    pub BaseDllName: UNICODE_STRING,
    pub Flags: ULONG,
    pub LoadCount: USHORT,
    pub TlsIndex: USHORT,
    pub HashLinks: LIST_ENTRY,
    pub SectionPointer: PVOID,
    pub CheckSum: ULONG,
    pub TimeDateStamp: ULONG,
}
#[test]
fn bindgen_test_layout__LDR_DATA_TABLE_ENTRY() {
    assert_eq!(
        ::core::mem::size_of::<_LDR_DATA_TABLE_ENTRY>(),
        144usize,
        concat!("Size of: ", stringify!(_LDR_DATA_TABLE_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LDR_DATA_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LDR_DATA_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).InLoadOrderModuleList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(InLoadOrderModuleList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).InMemoryOrderModuleList as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(InMemoryOrderModuleList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).InInitializationOrderModuleList as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(InInitializationOrderModuleList)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).DllBase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(DllBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).EntryPoint as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(EntryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).SizeOfImage as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).FullDllName as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(FullDllName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).BaseDllName as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(BaseDllName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).Flags as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).LoadCount as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(LoadCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).TlsIndex as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(TlsIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).HashLinks as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(HashLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).SectionPointer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(SectionPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).CheckSum as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_LDR_DATA_TABLE_ENTRY>())).TimeDateStamp as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
}
extern "C" {
    pub fn RtlFindExportedRoutineByName(ImageBase: PVOID, RoutineName: PCCH) -> PVOID;
}
extern "C" {
    pub fn PsGetProcessWow64Process(Process: PEPROCESS) -> PVOID;
}
extern "C" {
    pub fn PsGetProcessPeb(Process: PEPROCESS) -> PPEB;
}
extern "C" {
    pub fn MmCopyVirtualMemory(
        SourceProcess: PEPROCESS, SourceAddress: PVOID, TargetProcess: PEPROCESS, TargetAddress: PVOID,
        BufferSize: SIZE_T, PreviousMode: KPROCESSOR_MODE, ReturnSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQuerySystemInformation(InfoClass: ULONG, Buffer: PVOID, Length: ULONG, ReturnLength: PULONG) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EPROCESS {
    pub _address: u8,
}
