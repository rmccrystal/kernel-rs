/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type wchar_t = crate::include::raw::c_ushort;
pub type ULONG_PTR = crate::include::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type LONG64 = crate::include::raw::c_longlong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut crate::include::raw::c_void;
pub type CHAR = crate::include::raw::c_char;
pub type SHORT = crate::include::raw::c_short;
pub type LONG = crate::include::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCH = *mut WCHAR;
pub type PCHAR = *mut CHAR;
pub type PCCH = *const CHAR;
pub type UCHAR = crate::include::raw::c_uchar;
pub type USHORT = crate::include::raw::c_ushort;
pub type ULONG = crate::include::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type HANDLE = *mut crate::include::raw::c_void;
pub type CCHAR = crate::include::raw::c_char;
pub type CSHORT = crate::include::raw::c_short;
pub type LCID = ULONG;
pub type NTSTATUS = LONG;
pub type LONGLONG = crate::include::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}
pub type UNICODE_STRING = _UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type BOOLEAN = UCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
pub type LIST_ENTRY = _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: ULONG,
    pub Blink: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING32 {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: ULONG,
}
pub type STRING32 = _STRING32;
pub type UNICODE_STRING32 = STRING32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: crate::include::raw::c_ulong,
    pub Data2: crate::include::raw::c_ushort,
    pub Data3: crate::include::raw::c_ushort,
    pub Data4: [crate::include::raw::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type KIRQL = UCHAR;
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    _unused: [u8; 0],
}
pub type PEPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD {
    _unused: [u8; 0],
}
pub type PETHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    _unused: [u8; 0],
}
pub type PIO_TIMER = *mut _IO_TIMER;
pub type PRKPROCESS = *mut _KPROCESS;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PVPB = *mut _VPB;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
}
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
pub type SECURITY_INFORMATION = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
    _bindgen_union_align: u64,
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileIdBothDirectoryInformation = 37,
    FileIdFullDirectoryInformation = 38,
    FileValidDataLengthInformation = 39,
    FileShortNameInformation = 40,
    FileIoCompletionNotificationInformation = 41,
    FileIoStatusBlockRangeInformation = 42,
    FileIoPriorityHintInformation = 43,
    FileSfioReserveInformation = 44,
    FileSfioVolumeInformation = 45,
    FileHardLinkInformation = 46,
    FileProcessIdsUsingFileInformation = 47,
    FileNormalizedNameInformation = 48,
    FileNetworkPhysicalNameInformation = 49,
    FileIdGlobalTxDirectoryInformation = 50,
    FileIsRemoteDeviceInformation = 51,
    FileUnusedInformation = 52,
    FileNumaNodeInformation = 53,
    FileStandardLinkInformation = 54,
    FileRemoteProtocolInformation = 55,
    FileRenameInformationBypassAccessCheck = 56,
    FileLinkInformationBypassAccessCheck = 57,
    FileVolumeNameInformation = 58,
    FileIdInformation = 59,
    FileIdExtdDirectoryInformation = 60,
    FileReplaceCompletionInformation = 61,
    FileHardLinkFullIdInformation = 62,
    FileIdExtdBothDirectoryInformation = 63,
    FileDispositionInformationEx = 64,
    FileRenameInformationEx = 65,
    FileRenameInformationExBypassAccessCheck = 66,
    FileDesiredStorageClassInformation = 67,
    FileStatInformation = 68,
    FileMemoryPartitionInformation = 69,
    FileStatLxInformation = 70,
    FileCaseSensitiveInformation = 71,
    FileLinkInformationEx = 72,
    FileLinkInformationExBypassAccessCheck = 73,
    FileStorageReserveIdInformation = 74,
    FileCaseSensitiveInformationForceAccessCheck = 75,
    FileKnownFolderInformation = 76,
    FileMaximumInformation = 77,
}
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DIRECTORY_NOTIFY_INFORMATION_CLASS {
    DirectoryNotifyInformation = 1,
    DirectoryNotifyExtendedInformation = 2,
}
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS as DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsDriverPathInformation = 9,
    FileFsVolumeFlagsInformation = 10,
    FileFsSectorSizeInformation = 11,
    FileFsDataCopyInformation = 12,
    FileFsMetadataSizeInformation = 13,
    FileFsFullSizeInformationEx = 14,
    FileFsMaximumInformation = 15,
}
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    ACPIBus = 17,
    MaximumInterfaceType = 18,
}
pub use self::_INTERFACE_TYPE as INTERFACE_TYPE;
pub type PINTERFACE_REFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
pub type PINTERFACE_DEREFERENCE = ::core::option::Option<unsafe extern "C" fn(Context: PVOID)>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
}
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
}
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
    _bindgen_union_align: u32,
}
pub type POWER_STATE = _POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1,
}
pub use self::_POWER_STATE_TYPE as POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub ContextAsUlong: ULONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectedDripsTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        KernelSoftReboot: ULONG,
        DirectedDripsTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let TargetSystemState: u32 = unsafe { ::core::mem::transmute(TargetSystemState) };
            TargetSystemState as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let EffectiveSystemState: u32 = unsafe { ::core::mem::transmute(EffectiveSystemState) };
            EffectiveSystemState as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CurrentSystemState: u32 = unsafe { ::core::mem::transmute(CurrentSystemState) };
            CurrentSystemState as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let IgnoreHibernationPath: u32 =
                unsafe { ::core::mem::transmute(IgnoreHibernationPath) };
            IgnoreHibernationPath as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let PseudoTransition: u32 = unsafe { ::core::mem::transmute(PseudoTransition) };
            PseudoTransition as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let KernelSoftReboot: u32 = unsafe { ::core::mem::transmute(KernelSoftReboot) };
            KernelSoftReboot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DirectedDripsTransition: u32 =
                unsafe { ::core::mem::transmute(DirectedDripsTransition) };
            DirectedDripsTransition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Translated:
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IRQ_DEVICE_POLICY {
    IrqPolicyMachineDefault = 0,
    IrqPolicyAllCloseProcessors = 1,
    IrqPolicyOneCloseProcessor = 2,
    IrqPolicyAllProcessorsInMachine = 3,
    IrqPolicySpecifiedProcessors = 4,
    IrqPolicySpreadMessagesAcrossAllProcessors = 5,
    IrqPolicyAllProcessorsInMachineWhenSteered = 6,
}
pub use self::_IRQ_DEVICE_POLICY as IRQ_DEVICE_POLICY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IRQ_PRIORITY {
    IrqPriorityUndefined = 0,
    IrqPriorityLow = 1,
    IrqPriorityNormal = 2,
    IrqPriorityHigh = 3,
}
pub use self::_IRQ_PRIORITY as IRQ_PRIORITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
pub use self::_POOL_TYPE as POOL_TYPE;
pub type KPROCESSOR_MODE = CCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub SpareByte0: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
pub type KAPC = _KAPC;
pub type KDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: *mut _KDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
pub type PMDL = *mut _MDL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: LONG,
    pub LockNV: LONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR,
        Wake: UCHAR,
        EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Absolute: u8 = unsafe { ::core::mem::transmute(Absolute) };
            Absolute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Wake: u8 = unsafe { ::core::mem::transmute(Wake) };
            Wake as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let EncodedTolerableDelay: u8 =
                unsafe { ::core::mem::transmute(EncodedTolerableDelay) };
            EncodedTolerableDelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Index: UCHAR,
        Inserted: UCHAR,
        Expired: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let Index: u8 = unsafe { ::core::mem::transmute(Index) };
            Index as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Inserted: u8 = unsafe { ::core::mem::transmute(Inserted) };
            Inserted as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Expired: u8 = unsafe { ::core::mem::transmute(Expired) };
            Expired as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2ComponentId: UCHAR,
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR,
        Timer2Expiring: UCHAR,
        Timer2CancelPending: UCHAR,
        Timer2SetPending: UCHAR,
        Timer2Running: UCHAR,
        Timer2Disabled: UCHAR,
        Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Timer2Inserted: u8 = unsafe { ::core::mem::transmute(Timer2Inserted) };
            Timer2Inserted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Timer2Expiring: u8 = unsafe { ::core::mem::transmute(Timer2Expiring) };
            Timer2Expiring as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Timer2CancelPending: u8 = unsafe { ::core::mem::transmute(Timer2CancelPending) };
            Timer2CancelPending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Timer2SetPending: u8 = unsafe { ::core::mem::transmute(Timer2SetPending) };
            Timer2SetPending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Timer2Running: u8 = unsafe { ::core::mem::transmute(Timer2Running) };
            Timer2Running as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Timer2Disabled: u8 = unsafe { ::core::mem::transmute(Timer2Disabled) };
            Timer2Disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Timer2ReservedFlags: u8 = unsafe { ::core::mem::transmute(Timer2ReservedFlags) };
            Timer2ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR,
        DisableIncrement: UCHAR,
        QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
            Abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableIncrement: u8 = unsafe { ::core::mem::transmute(DisableIncrement) };
            DisableIncrement as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let QueueReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(QueueReservedControlFlags) };
            QueueReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SchedulerAssist(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SchedulerAssist(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR,
        CounterProfiling: UCHAR,
        GroupScheduling: UCHAR,
        AffinitySet: UCHAR,
        Tagged: UCHAR,
        EnergyProfiling: UCHAR,
        SchedulerAssist: UCHAR,
        ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CycleProfiling: u8 = unsafe { ::core::mem::transmute(CycleProfiling) };
            CycleProfiling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CounterProfiling: u8 = unsafe { ::core::mem::transmute(CounterProfiling) };
            CounterProfiling as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GroupScheduling: u8 = unsafe { ::core::mem::transmute(GroupScheduling) };
            GroupScheduling as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AffinitySet: u8 = unsafe { ::core::mem::transmute(AffinitySet) };
            AffinitySet as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Tagged: u8 = unsafe { ::core::mem::transmute(Tagged) };
            Tagged as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EnergyProfiling: u8 = unsafe { ::core::mem::transmute(EnergyProfiling) };
            EnergyProfiling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SchedulerAssist: u8 = unsafe { ::core::mem::transmute(SchedulerAssist) };
            SchedulerAssist as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ThreadReservedControlFlags: u8 =
                unsafe { ::core::mem::transmute(ThreadReservedControlFlags) };
            ThreadReservedControlFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: UCHAR,
    pub __bindgen_anon_1:
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ActiveDR7(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ActiveDR7(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Instrumented(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Minimal(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Minimal(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn AltSyscall(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AltSyscall(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Emulation(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Emulation(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveDR7: BOOLEAN,
        Instrumented: BOOLEAN,
        Minimal: BOOLEAN,
        Reserved4: BOOLEAN,
        AltSyscall: BOOLEAN,
        Emulation: BOOLEAN,
        Reserved5: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ActiveDR7: u8 = unsafe { ::core::mem::transmute(ActiveDR7) };
            ActiveDR7 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Instrumented: u8 = unsafe { ::core::mem::transmute(Instrumented) };
            Instrumented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Minimal: u8 = unsafe { ::core::mem::transmute(Minimal) };
            Minimal as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let Reserved4: u8 = unsafe { ::core::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AltSyscall: u8 = unsafe { ::core::mem::transmute(AltSyscall) };
            AltSyscall as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Emulation: u8 = unsafe { ::core::mem::transmute(Emulation) };
            Emulation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved5: u8 = unsafe { ::core::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2,
}
pub use self::_LOCK_OPERATION as LOCK_OPERATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    pub Busy: BOOLEAN,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Hint(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: LONG64,
        Hint: LONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Hint: u64 = unsafe { ::core::mem::transmute(Hint) };
            Hint as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6,
    MmNotMapped = -1,
}
pub use self::_MEMORY_CACHING_TYPE as MEMORY_CACHING_TYPE;
impl _POOL_TYPE {
    pub const NonPagedPoolExecute: _POOL_TYPE = _POOL_TYPE::NonPagedPool;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBase: _POOL_TYPE = _POOL_TYPE::NonPagedPool;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseMustSucceed: _POOL_TYPE = _POOL_TYPE::NonPagedPoolMustSucceed;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseCacheAligned: _POOL_TYPE = _POOL_TYPE::NonPagedPoolCacheAligned;
}
impl _POOL_TYPE {
    pub const NonPagedPoolBaseCacheAlignedMustS: _POOL_TYPE =
        _POOL_TYPE::NonPagedPoolCacheAlignedMustS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = 516,
    NonPagedPoolSessionNx = 544,
}
extern "C" {
    pub fn ExAllocatePoolWithTag(PoolType: POOL_TYPE, NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
extern "C" {
    pub fn ExFreePoolWithTag(P: PVOID, Tag: ULONG);
}
pub type ERESOURCE_THREAD = ULONG_PTR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub TableSize: ULONG,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG,
        OwnerReferenced: ULONG,
        IoQoSPriorityBoosted: ULONG,
        OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IoPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoPriorityBoosted) };
            IoPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OwnerReferenced: u32 = unsafe { ::core::mem::transmute(OwnerReferenced) };
            OwnerReferenced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoQoSPriorityBoosted: u32 = unsafe { ::core::mem::transmute(IoQoSPriorityBoosted) };
            IoQoSPriorityBoosted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let OwnerCount: u32 = unsafe { ::core::mem::transmute(OwnerCount) };
            OwnerCount as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OWNER_ENTRY = _OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: PVOID,
    pub ExclusiveWaiters: PVOID,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    pub Address: PVOID,
    pub CreatorBackTraceIndex: ULONG_PTR,
    _bindgen_union_align: u64,
}
extern "C" {
    pub fn MmProbeAndLockPages(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        Operation: LOCK_OPERATION,
    );
}
extern "C" {
    pub fn MmUnlockPages(MemoryDescriptorList: PMDL);
}
extern "C" {
    pub fn MmProtectMdlSystemAddress(MemoryDescriptorList: PMDL, NewProtect: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn MmMapLockedPagesSpecifyCache(
        MemoryDescriptorList: PMDL,
        AccessMode: KPROCESSOR_MODE,
        CacheType: MEMORY_CACHING_TYPE,
        RequestedAddress: PVOID,
        BugCheckOnFailure: ULONG,
        Priority: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn MmUnmapLockedPages(BaseAddress: PVOID, MemoryDescriptorList: PMDL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
    _bindgen_union_align: [u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {
    _unused: [u8; 0],
}
pub type DRIVER_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        RegistryPath: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
#[doc = ""]
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_STARTIO =
    ::core::option::Option<unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP)>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD =
    ::core::option::Option<unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT)>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        CheckForReadOperation: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_BASIC_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_STANDARD_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PEPROCESS,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PVOID,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IoControlCode: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE =
    ::core::option::Option<unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT)>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(SourceDevice: *mut _DEVICE_OBJECT, TargetDevice: *mut _DEVICE_OBJECT),
>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: *mut _FILE_NETWORK_OPEN_INFORMATION,
        IoStatus: *mut _IO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        EndingOffset: PLARGE_INTEGER,
        ResourceToRelease: *mut *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ResourceToRelease: *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    _unused: [u8; 0],
}
pub type FAST_IO_READ_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN = ::core::option::Option<
    unsafe extern "C" fn(
        Irp: *mut _IRP,
        NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3,
}
pub use self::_IO_ALLOCATION_ACTION as IO_ALLOCATION_ACTION;
pub type DRIVER_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        MapRegisterBase: PVOID,
        Context: PVOID,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn NumberOfRemapPages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_NumberOfRemapPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG,
        DmaContext: ULONG,
        ZeroMapRegisters: ULONG,
        Reserved: ULONG,
        NumberOfRemapPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncCallback: u32 = unsafe { ::core::mem::transmute(SyncCallback) };
            SyncCallback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaContext: u32 = unsafe { ::core::mem::transmute(DmaContext) };
            DmaContext as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ZeroMapRegisters: u32 = unsafe { ::core::mem::transmute(ZeroMapRegisters) };
            ZeroMapRegisters as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let NumberOfRemapPages: u32 = unsafe { ::core::mem::transmute(NumberOfRemapPages) };
            NumberOfRemapPages as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
    _bindgen_union_align: [u64; 9usize],
}
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub InterruptCount: LONG,
    pub VerifierContext: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_3,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub MasterIrp: *mut _IRP,
    pub IrpCount: LONG,
    pub SystemBuffer: PVOID,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub UserIosb: PIO_STATUS_BLOCK,
    pub IoRingContext: PVOID,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    pub AsynchronousParameters: _IRP__bindgen_ty_3__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: PVOID,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub UserApcContext: PVOID,
    pub IoRing: *mut _IORING_OBJECT,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4 {
    pub Overlay: _IRP__bindgen_ty_4__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
    _bindgen_union_align: [u64; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    pub PacketType: ULONG,
    _bindgen_union_align: u64,
}
pub type IRP = _IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Context: PVOID) -> NTSTATUS,
>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4,
    SingleBusRelations = 5,
    TransportRelations = 6,
}
pub use self::_DEVICE_RELATION_TYPE as DEVICE_RELATION_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3,
    DeviceUsageTypeBoot = 4,
    DeviceUsageTypePostDisplay = 5,
    DeviceUsageTypeGuestAssigned = 6,
}
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE as DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ChildOfVgaEnabledBridge(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChildOfVgaEnabledBridge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DecodeIoOnBoot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DecodeIoOnBoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved1: ULONG,
        WakeFromInterrupt: ULONG,
        SecureDevice: ULONG,
        ChildOfVgaEnabledBridge: ULONG,
        DecodeIoOnBoot: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeviceD1: u32 = unsafe { ::core::mem::transmute(DeviceD1) };
            DeviceD1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DeviceD2: u32 = unsafe { ::core::mem::transmute(DeviceD2) };
            DeviceD2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LockSupported: u32 = unsafe { ::core::mem::transmute(LockSupported) };
            LockSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EjectSupported: u32 = unsafe { ::core::mem::transmute(EjectSupported) };
            EjectSupported as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
            Removable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DockDevice: u32 = unsafe { ::core::mem::transmute(DockDevice) };
            DockDevice as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UniqueID: u32 = unsafe { ::core::mem::transmute(UniqueID) };
            UniqueID as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SilentInstall: u32 = unsafe { ::core::mem::transmute(SilentInstall) };
            SilentInstall as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RawDeviceOK: u32 = unsafe { ::core::mem::transmute(RawDeviceOK) };
            RawDeviceOK as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SurpriseRemovalOK: u32 = unsafe { ::core::mem::transmute(SurpriseRemovalOK) };
            SurpriseRemovalOK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WakeFromD0: u32 = unsafe { ::core::mem::transmute(WakeFromD0) };
            WakeFromD0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WakeFromD1: u32 = unsafe { ::core::mem::transmute(WakeFromD1) };
            WakeFromD1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WakeFromD2: u32 = unsafe { ::core::mem::transmute(WakeFromD2) };
            WakeFromD2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WakeFromD3: u32 = unsafe { ::core::mem::transmute(WakeFromD3) };
            WakeFromD3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HardwareDisabled: u32 = unsafe { ::core::mem::transmute(HardwareDisabled) };
            HardwareDisabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NonDynamic: u32 = unsafe { ::core::mem::transmute(NonDynamic) };
            NonDynamic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WarmEjectSupported: u32 = unsafe { ::core::mem::transmute(WarmEjectSupported) };
            WarmEjectSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let NoDisplayInUI: u32 = unsafe { ::core::mem::transmute(NoDisplayInUI) };
            NoDisplayInUI as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WakeFromInterrupt: u32 = unsafe { ::core::mem::transmute(WakeFromInterrupt) };
            WakeFromInterrupt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SecureDevice: u32 = unsafe { ::core::mem::transmute(SecureDevice) };
            SecureDevice as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ChildOfVgaEnabledBridge: u32 =
                unsafe { ::core::mem::transmute(ChildOfVgaEnabledBridge) };
            ChildOfVgaEnabledBridge as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DecodeIoOnBoot: u32 = unsafe { ::core::mem::transmute(DecodeIoOnBoot) };
            DecodeIoOnBoot as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BUS_QUERY_ID_TYPE {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4,
    BusQueryContainerID = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DEVICE_TEXT_TYPE {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1:
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub Lock: BOOLEAN,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerState: SYSTEM_POWER_STATE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub Type: POWER_STATE_TYPE,
    pub __bindgen_padding_1: u32,
    pub State: POWER_STATE,
    pub __bindgen_padding_2: u32,
    pub ShutdownType: POWER_ACTION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    pub SystemContext: ULONG,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
extern "C" {
    pub fn IoAllocateMdl(
        VirtualAddress: PVOID,
        Length: ULONG,
        SecondaryBuffer: BOOLEAN,
        ChargeQuota: BOOLEAN,
        Irp: PIRP,
    ) -> PMDL;
}
extern "C" {
    pub fn IoFreeMdl(Mdl: PMDL);
}
extern "C" {
    pub fn IoGetCurrentProcess() -> PEPROCESS;
}
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [UCHAR; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: UCHAR,
    pub SubAuthorityCount: UCHAR,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [ULONG; 1usize],
}
pub type SID = _SID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub Sid: SID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: *mut _KPROCESS,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1,
    pub KernelApcPending: BOOLEAN,
    pub __bindgen_anon_2: _KAPC_STATE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_1 {
    pub InProgressFlags: UCHAR,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _KAPC_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn KernelApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_KernelApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpecialApcInProgress(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SpecialApcInProgress(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        KernelApcInProgress: BOOLEAN,
        SpecialApcInProgress: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let KernelApcInProgress: u8 = unsafe { ::core::mem::transmute(KernelApcInProgress) };
            KernelApcInProgress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SpecialApcInProgress: u8 = unsafe { ::core::mem::transmute(SpecialApcInProgress) };
            SpecialApcInProgress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KAPC_STATE__bindgen_ty_2 {
    pub UserApcPendingAll: BOOLEAN,
    pub __bindgen_anon_1: _KAPC_STATE__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl _KAPC_STATE__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SpecialUserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SpecialUserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserApcPending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UserApcPending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SpecialUserApcPending: BOOLEAN,
        UserApcPending: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SpecialUserApcPending: u8 =
                unsafe { ::core::mem::transmute(SpecialUserApcPending) };
            SpecialUserApcPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UserApcPending: u8 = unsafe { ::core::mem::transmute(UserApcPending) };
            UserApcPending as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PRKAPC_STATE = *mut _KAPC_STATE;
extern "C" {
    pub fn KeStackAttachProcess(PROCESS: PRKPROCESS, ApcState: PRKAPC_STATE);
}
extern "C" {
    pub fn KeUnstackDetachProcess(ApcState: PRKAPC_STATE);
}
pub type BYTE = crate::include::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDC__ {
    pub unused: crate::include::raw::c_int,
}
pub type HDC = *mut HDC__;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_PROCESS_MODULE_INFORMATION {
    pub Section: HANDLE,
    pub MappedBase: PVOID,
    pub ImageBase: PVOID,
    pub ImageSize: ULONG,
    pub Flags: ULONG,
    pub LoadOrderIndex: USHORT,
    pub InitOrderIndex: USHORT,
    pub LoadCount: USHORT,
    pub OffsetToFileName: USHORT,
    pub FullPathName: [UCHAR; 256usize],
}
pub type RTL_PROCESS_MODULE_INFORMATION = _RTL_PROCESS_MODULE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_PROCESS_MODULES {
    pub NumberOfModules: ULONG,
    pub Modules: [RTL_PROCESS_MODULE_INFORMATION; 1usize],
}
pub type PRTL_PROCESS_MODULES = *mut _RTL_PROCESS_MODULES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA32 {
    pub Length: ULONG,
    pub Initialized: UCHAR,
    pub SsHandle: ULONG,
    pub InLoadOrderModuleList: LIST_ENTRY32,
    pub InMemoryOrderModuleList: LIST_ENTRY32,
    pub InInitializationOrderModuleList: LIST_ENTRY32,
}
pub type PPEB_LDR_DATA32 = *mut _PEB_LDR_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY32 {
    pub InLoadOrderLinks: LIST_ENTRY32,
    pub InMemoryOrderLinks: LIST_ENTRY32,
    pub InInitializationOrderLinks: LIST_ENTRY32,
    pub DllBase: ULONG,
    pub EntryPoint: ULONG,
    pub SizeOfImage: ULONG,
    pub FullDllName: UNICODE_STRING32,
    pub BaseDllName: UNICODE_STRING32,
    pub Flags: ULONG,
    pub LoadCount: USHORT,
    pub TlsIndex: USHORT,
    pub HashLinks: LIST_ENTRY32,
    pub TimeDateStamp: ULONG,
}
pub type LDR_DATA_TABLE_ENTRY32 = _LDR_DATA_TABLE_ENTRY32;
pub type PLDR_DATA_TABLE_ENTRY32 = *mut _LDR_DATA_TABLE_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB32 {
    pub InheritedAddressSpace: UCHAR,
    pub ReadImageFileExecOptions: UCHAR,
    pub BeingDebugged: UCHAR,
    pub BitField: UCHAR,
    pub Mutant: ULONG,
    pub ImageBaseAddress: ULONG,
    pub Ldr: ULONG,
    pub ProcessParameters: ULONG,
    pub SubSystemData: ULONG,
    pub ProcessHeap: ULONG,
    pub FastPebLock: ULONG,
    pub AtlThunkSListPtr: ULONG,
    pub IFEOKey: ULONG,
    pub CrossProcessFlags: ULONG,
    pub UserSharedInfoPtr: ULONG,
    pub SystemReserved: ULONG,
    pub AtlThunkSListPtr32: ULONG,
    pub ApiSetMap: ULONG,
}
pub type PPEB32 = *mut _PEB32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA {
    pub Length: ULONG,
    pub Initialized: BOOLEAN,
    pub SsHandle: PVOID,
    pub ModuleListLoadOrder: LIST_ENTRY,
    pub ModuleListMemoryOrder: LIST_ENTRY,
    pub ModuleListInitOrder: LIST_ENTRY,
}
pub type PPEB_LDR_DATA = *mut _PEB_LDR_DATA;
pub type PPS_POST_PROCESS_INIT_ROUTINE = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
    pub Reserved1: [BYTE; 16usize],
    pub Reserved2: [PVOID; 10usize],
    pub ImagePathName: UNICODE_STRING,
    pub CommandLine: UNICODE_STRING,
}
pub type PRTL_USER_PROCESS_PARAMETERS = *mut _RTL_USER_PROCESS_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PEB {
    pub Reserved1: [BYTE; 2usize],
    pub BeingDebugged: BYTE,
    pub Reserved2: [BYTE; 1usize],
    pub Reserved3: [PVOID; 2usize],
    pub Ldr: PPEB_LDR_DATA,
    pub ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
    pub Reserved4: [PVOID; 3usize],
    pub AtlThunkSListPtr: PVOID,
    pub Reserved5: PVOID,
    pub Reserved6: ULONG,
    pub Reserved7: PVOID,
    pub Reserved8: ULONG,
    pub AtlThunkSListPtr32: ULONG,
    pub Reserved9: [PVOID; 45usize],
    pub Reserved10: [BYTE; 96usize],
    pub PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    pub Reserved11: [BYTE; 128usize],
    pub Reserved12: [PVOID; 1usize],
    pub SessionId: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY {
    pub InLoadOrderModuleList: LIST_ENTRY,
    pub InMemoryOrderModuleList: LIST_ENTRY,
    pub InInitializationOrderModuleList: LIST_ENTRY,
    pub DllBase: PVOID,
    pub EntryPoint: PVOID,
    pub SizeOfImage: ULONG,
    pub FullDllName: UNICODE_STRING,
    pub BaseDllName: UNICODE_STRING,
    pub Flags: ULONG,
    pub LoadCount: USHORT,
    pub TlsIndex: USHORT,
    pub HashLinks: LIST_ENTRY,
    pub SectionPointer: PVOID,
    pub CheckSum: ULONG,
    pub TimeDateStamp: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFO {
    pub NextEntryOffset: ULONG,
    pub NumberOfThreads: ULONG,
    pub Reserved: [LARGE_INTEGER; 3usize],
    pub CreateTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
    pub KernelTime: LARGE_INTEGER,
    pub ImageName: UNICODE_STRING,
    pub BasePriority: ULONG,
    pub ProcessId: HANDLE,
    pub InheritedFromProcessId: HANDLE,
}
pub type SYSTEM_PROCESS_INFO = _SYSTEM_PROCESS_INFO;
extern "C" {
    pub fn RtlFindExportedRoutineByName(ImageBase: PVOID, RoutineName: PCCH) -> PVOID;
}
extern "C" {
    pub fn PsGetProcessWow64Process(Process: PEPROCESS) -> PVOID;
}
extern "C" {
    pub fn PsGetProcessPeb(Process: PEPROCESS) -> PPEB;
}
extern "C" {
    pub fn MmCopyVirtualMemory(
        SourceProcess: PEPROCESS,
        SourceAddress: PVOID,
        TargetProcess: PEPROCESS,
        TargetAddress: PVOID,
        BufferSize: SIZE_T,
        PreviousMode: KPROCESSOR_MODE,
        ReturnSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn ZwQuerySystemInformation(
        InfoClass: ULONG,
        Buffer: PVOID,
        Length: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EPROCESS {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IORING_OBJECT {
    pub _address: u8,
}
